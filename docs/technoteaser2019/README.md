# SAP Техноблъсканица 2019

<link rel="stylesheet" href="../styles/technoteaser.css">
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

## Седмица №1

Играем в телевизионна игра. Разполагаме с 8 еднакви и неразличими на външен вид кутии, във всяка от които има по 2 камъчета. Всяко камъче може да бъде скъпоценно или не. Избираме една кутия и водещият, без да поглежда в нея, изважда едно от камъчетата. То се оказва скъпоценно. Тогава водещият заявява, че имаме точно 50% шанс и второто камъче в тази кутия да е скъпоценно.<br>
Ако знаем, че първоначално броят на скъпоценните камъчета е не по-малък от броя на нескъпоценните, кои от следните твърдения трябва да са верни?<br>
Приемаме, че водещият знае разпределението на камъчетата в кутиите - в колко кутии скъпоценните камъчета са 2, в колко е 1 и в колко са 0. Водещият обаче не знае какви са камъчетата в една конкретна кутия, тъй като самият той не различава кутиите. 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution11><label class="explanationbutton" for=solution11><span>Обяснения</span></label>
	<div class="explanation">
В оригинал задачата е популярна като <a href="https://en.wikibooks.org/wiki/Puzzles/Statistical_puzzles/3_Bags_of_Marbles" target="_blank">3 Bags of Marbles</a>, като най-подвеждащото в случая е да съобразим, че въпреки избора на кутия, реално имаме информация само за едно единствено камъче. Можем да се окажем в ситуацията да сме избрали кутия с две скъпоценни камъчета (нека я наречем печеливша) по два различни начина - като изтеглим първото или като изтеглим второто скъпоценно камъче от нея. От друга страна можем да се окажем в ситуацията да сме избрали непечеливша кутия само по един единствен начин - като сме изтеглили единственото пeчелившо камъче от нея.
<h3>Какво е разпределението на камъчетата?</h3>
Означаваме броя на кутиите с по 1 скъпоценно камъче (т.е. броя на непечелившите кутии) с <b title="Брой кутии с едно скъпоценно камъче">x</b>.<br>
Очевидно имаме поне 1 кутия с 2 скъпоценни камъчета, в противен случай шансът за второ скъпоценно камъче в избраната от нас кутия ще бъде 0%.<br>
1. Предполагаме, че първоначално в играта е имало 1 единствена кутия с 2 скъпоценни камъчета в нея. 
Номерираме всички скъпоценни камъчета с v<sub>i</sub> (valuable) и всички нескъпoценни с n<sub>i</sub> (not valuable)<br> 
<style> 
.box {border-style: solid; border-width: 1px; border-radius: 4px 4px 0px 0px; border-color:grey; margin:5px 5px 5px 5px; padding: 0px 2px 1px 2px; background-color:#f7f7f7;white-space: nowrap; line-height: 150%;}
</style>
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, n<sub>1</sub></span>...<span class="box">v<sub>2+x</sub>, n<sub>x</sub></span>
<br>
По колко начина може да сме стигнали до кутия с извадено скъпоценно камъче?<br>
От печеливша кутия: Изтеглено е v<sub>1</sub> или v<sub>2</sub><br>
От непечеливша кутия:  Изтеглено е v<sub>3</sub> или v<sub>4</sub> ... или v<sub>2+x</sub><br>
Тъй като двете вероятности според водещия са равни, то трябва да имаме точно 2 непечеливши случая и точно 2 кутии с по 1 скъпоценно камъче, т.е. <b title="Брой кутии с едно скъпоценно камъче">x</b>=2<br>
Получаваме общо 4 скъпоценни камъчета и 14 нескъпоценни. Но по условие скъпоценните са поне колкото нескъпоценните, затова 1 кутия с 2 скъпоценни камъчета не е възможно разпределение.<br> 
2. Ако предположим, че имаме 2 кутии с по 2 скъоценни камъчета, то <br> 
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, v<sub>4</sub></span> 
<span class="box">v<sub>5</sub>, n<sub>1</sub></span> 
...
<span class="box">v<sub>4+x</sub>, n<sub>x</sub></span>
<br>
Имаме 4 възможности за първо избрано камъче от печеливша кутия: v<sub>1</sub>,v<sub>2</sub>,v<sub>3</sub>,v<sub>4</sub><br>
За да имаме 4 възможности от непечеливша кутия, трябва да имаме 4 кутии с по 1 скъпоценно камъче (<b title="Брой кутии с едно скъпоценно камъче">x</b>=4)<br>
Получаваме **2 кутии с по 2 скъпоценни камъчета, 4 кутии с по 1 скъпоценнно камъче** и остават **2 кутии с 2 нескъпоценни камъчета**.<br>
3. Нека предположим, че имаме 3 кутии с по 2 скъпоценни камъчета. <br>
По аналогичен начим виждаме, че трябва да имаме <b title="Брой кутии с едно скъпоценно камъче">x</b>=6 кутии с по 1 скъпоценно камъче, но получаваме общо 3+6=9 кутии, а по условие имаме само 8. Същите разсъждения са валидни за всяко разпределение с повече от 3 печеливши кутии.<br>
Получихме единствено възможно разпределение на камъчетата, откъдето следват няколко верни твърдения:<br>
<nobr><span class="box" style="background-color:#eafff1">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box" style="background-color:#eafff1">v<sub>3</sub>, v<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#ffffed">v<sub>5</sub>, n<sub>1</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>6</sub>, n<sub>2</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>7</sub>, n<sub>3</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>8</sub>, n<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#f2e6e6">n<sub>5</sub>, n<sub>6</sub></span>
<span class="box" style="background-color:#f2e6e6">n<sub>7</sub>, n<sub>8</sub></span></nobr><br>
✔ _Първоначално в играта е имало точно 2 кутии с по два скъпоценни камъчета_ <br>
✔ _Първоначално половината кутии са имали по едно скъпоценно и едно нескъпоценно камъче_ <br>
✔ _Първоначално в играта е имало равен брой скъпоценни и нескъпоценни камъчета_ <br>
✔ _Първоначално броят на кутиите с 2 скъпоценни камъчета е равен на броя на кутиите с 2 нескъпоценни камъчета_ <br>
<h3>Защо остават нечетен брой камъчета и 50% вероятност за второ скъпоценно камъче?</h3>
След като сме изтеглили и видели едно от камъчетата, не всички останали камъчета участват с еднакво тегло в изчисляването на вероятността за това какво е второто камъче в кутия ни. Например броят на кутиите с по 2 нескъпоценни камъчета и съответно камъчетата от n<sub>5</sub> до n<sub>8</sub> не влияят по никакъв начин на тази вероятност.<br>
Друг поглед върху ситуацията е, че с второто камъче определяме типа кутия. В случая сме имали 50% шанс да изберем първото скъпоценно камъче и текущ шанс 50% за второ скъпоценно камъче, т.е. обща вероятност от 50%∗50%=25% за кутия с 2 скъпоценни камъчета.
<h3>Как променяме шанса си при смяна на кутията?</h3>
От 4-те непечеливши комбинации (камъчета от v<sub>5</sub> до v<sub>8</sub>), когато в кутията ни има второ нескъпоценно камъче, при премахването на нашата кутия в играта остават равен брой скъпоценни и нескъпоценни камъчета и ⇒ 50% шанс за това второто изтеглено камъче да е скъпоценно.<br>
От 4-те печеливши комбинации обаче (камъчета от v<sub>1</sub> до v<sub>4</sub>), когато в кутията ни има второ скъпоценно камъче, при премахването на нашата кутия в играта остават 6 скъпоценни и 8 нескъпоценни камъчета, т.е. имаме шанс за успех 6/14≈42.857%<br> 
Сумарно при смяна на кутиите шансът ни за второ скъпоценно камъче ще бъде по-малък ( ≈ 46.4%).
<hr>
<h3>Проверка на решението</h3>
Тъй като задачата е наистина заблуждаваща, с което е и станала известна, как можем да проверим, че решението е вярно? Все пак теорията на вероятностите е точна наука и един конкретен изход от една конкретна ситуация трябва да се сбъдва с една единствена вероятност, т.е. различни интерпретации са невъзможни.<br>
Нека вземем предложеното решение за кутии и разиграем достатъчно много на брой пъти ситуацията (например 10 000 пъти), за да придобием представа за вероятността. За целта ще напишем програма, която дословно следва условието на задачата, т.е.
1. На случаен принцип избираме една от осемте налични кутии
2. На случаен принцип избираме едно камъче от вече избраната кутия
3. Ако камъчето е нескъпоценно, игнорираме ситуацията, защото не отговаря на условието (продължаваме нататък без да правим нищо)
4. Ако камъчето е скъпоценно, преброяваме ситуацията като печеливша или не спрямо второто камъче в избраната кутия
Примерна програма на Java, преброяваща 10 000 валидни ситуации:
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; //,{0,0},{0,0}
Random r = new Random();
int successfullPositions = 0;
int unsuccessfullPositions = 0;
for(int i=0; i<10000; i++) {
	int boxIndex = r.nextInt(setup.length);
	int[] box = setup[boxIndex];
	int firstMarbleIndex = r.nextInt(2); 
	int marble = box[firstMarbleIndex];
	if (marble != 1) {
		i--;
		continue;
	}
	int secondMarbleIndex = (firstMarbleIndex+1)%2;
	if (box[secondMarbleIndex] == 1) {
		successfullPositions++;
	} else {
		unsuccessfullPositions++;
	}
}
System.out.println("successful:" + successfullPositions + "; unsuccessful:" + unsuccessfullPositions);
```

{::nomarkdown}
Единственото отклонение от оригиналната ситуация е премахването на двете кутии с по 2 нескъпоценни камъчета в тях, понеже те добавят само неефективност в изпълнението, а програмата би връщала същия резултат и без тях. Примерен резултат:
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:5010; unsuccessful:4990</div>
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:4981; unsuccessful:5019</div>
<br>
Изпълнение на програмата при равен брой кутии с по 2 и с по 1 скъпоценно камъче също показва достатъчно ясно два пъти повече печеливши ситуации спрямо непечелившите.
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; 
```

{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:6572; unsuccessful:3428</div>		
			
		
	</div> 
</div>
{:/}


<hr>

Колко са естествените числа (цели положителни числа ≥ 1), които са равни на произведението от цифрите си?<br>
Ако са безкрайно много, отговорете с английската буква i (от infinitely many) 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution12><label class="explanationbutton" for=solution12><span>Обяснение</span></label>
	<div class="explanation">
Разглеждаме естествените числа, които имат k цифри (k≥1) и първа цифра d<sub>1</sub>.<br>
Произведението от цифрите e най-голямо, когато всяка цифра след d<sub>1</sub> е 9, т.е. то е ≤ d<sub>1</sub>∗9<sup>k-1</sup><br>
Самото число е най-малко, когато цифрите след d<sub>1</sub> са 0, т.е. числото е  ≥ d<sub>1</sub>∗10<sup>k-1</sup>.<br>
d<sub>1</sub>∗9<sup>k-1</sup> = d<sub>1</sub>∗10<sup>k-1</sup> само при к=1<br>
⇒ едноцифрените числа от 1 до 9 (<b>общо 9 на брой</b>) са единствените естествени числа с това свойство.	
	</div> 
</div>
{:/}

<hr>

Ученик неволно откъснал един лист от учебника си по математика. След това пресметнал сумата от номерата на останалите страници в учебника и получил 2019 +/- 1 (2018, 2019 или 2020, за да бъдем по-точни).<br>
Колко страници е имал първоначално учебникът?<br>
Приемаме, че само последната страница в учебника може да бъде празна и неномерирана.<br>
Ако първоначалният брой страници не може да се определи еднозначно, моля отговорете с английската буква u (от undefined). 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution13><label class=explanationbutton for=solution13><span>Обяснение</span></label>
	<div class="explanation">
Нека учебникът има оригинално <i title="Оригинален брой страници на учебника"><b>X</b></i> страници с обща сума на страниците <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, сума на страниците без откъснатия лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i> и сума на страниците на откъснатия лист <i title="Сума на страниците на откъснатия лист"><b>l</b></i>.<br>
Знаем, че <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>+<i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018, 2019 или 2020<br>
Какви предположения можем да направим за <i title="Сума на страниците на откъснатия лист"><b>l</b></i>?<br>
Ако сме откъснали последния лист, а последната страница е била празна, то <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Оригинален брой страници на учебника"><b>X</b></i>.<br>
В противен случай <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е сума на 2 последователни числа. Всеки лист съдържа нечетно число първа по ред страница и четно число втора по ред страница (с 1 по-голяма от първата). <i title="Сума на страниците на откъснатия лист"><b>l</b></i> e сума на нечетно и четно число ⇒ <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е нечетно число.<br><br>
Колко най-малко страници е имал учебникът?<br>
Нека разгледаме учебник, от който не сме скъсали лист, с X<sub>0</sub> страници и сума на страниците 2018.<br>
Номерата на страниците започват от 1 и завършват с X<sub>0</sub>, образувайки аритметична прогресия със сума = X<sub>0</sub>(X<sub>0</sub>+1)/2=2018, т.е.<nobr> X<sub>0</sub><sup>2</sup>+X<sub>0</sub>–2∗2018=0</nobr><br>
Положителният корен на квадратното уравнение e \( X_0 = \dfrac{-1+\sqrt{1+4*2*2018}}{2} \), <nobr>X<sub>0</sub> ≈ 63,03</nobr><br>
<!-- (-1+√<span style="text-decoration: overline;">1+4∗2∗2018</span>)/2= 126/2 -->
Нашият учебник е с един лист повече и следователно <i title="Оригинален брой страници на учебника"><b>X</b></i>≥64<br>
1. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=64 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=64∗65/2=2080 страници<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2018=62 страници, което е четно число и не може да е сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2019=61 страници = 30+31, но първата страница е четна и следователно също не може да е първа страница от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2020=60 страници и също не могат да са от един лист.<br>
=> Учебникът няма как да е имал 64 страници.<br>
2. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=65∗66/2=2145<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2018=127=63+64. Това е предпоследният лист от учебник с 65 страници и сума на страниците без този лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 => <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 e възможен отговор.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2019=126 и не може да бъде сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2020=125=62+63, които отново не са страници на един лист.
3. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=66 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=66∗67/2=2211, но дори за най-голямото <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=191=95+96, а учебникът в този случай има само 66 страници.<br> Същите съображения са валидни и за <i title="Оригинален брой страници на учебника"><b>X</b></i>>66.<br>

Получихме единствено решение при учебник с <b>65</b> стр. <br>
Тъй като и тук има различни интерпретации за това дали трябва да преброим последната неномерирана страница или не, приемаме и отговор <b>66</b> за верен!	
	</div> 
</div>
{:/}

## Седмица №2

Миналата година (т.е. беше ден от 2018 г.) разговарях с Марто за неговия рожден ден. Той ми каза следното:

> Онзи ден (денят преди вчера) бях само на 14 години, но следващата година ставам на 17 години.

Каква е рождената дата на Марто?<br>
Приемаме, че на рождената си дата човек (през целия ден) е с 1 година по-възрастен, отколкото е бил на предходния ден.<br>
Моля, отговорете във формата dd.mm.yyyy (например 01.03.2019 за първи март 2019 г.) или с английската буква u (от undefined), ако рождената дата не може да бъде определена еднозначно. 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution21><label for=solution21 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Разговорът е проведен на 1 януари 2018 г.<br>
Марто има рожден ден на 31 декември.<br>
На 30.12.2017 (2 дена преди деня, в който се е провел разговора) е бил на 14.<br>
На 31.12.2017 е станал на 15.<br>
На 01.01.2018 (в деня на разговора) Марто е на 15 и през същата 2018-та година ще стане на 16.<br>
На 31.12.2019 (следващата година спрямо разговора) ще стане на 17.<br>
⇒ Марто е роден на <b>31.12.2002</b>
	</div> 
</div>
{:/}

<hr>

Катя е в първи клас и е добра по математика.<br>
Тя е написала следното изречение, заменяйки някои числа в него със символа _ (долна черта):

> В това изречение<br>
> цифрата 1 се среща _ път(и),<br>
> цифрата 2 се среща _ път(и),<br>
> цифрата 3 се среща _ път(и),<br>
> цифрата 4 се среща _ път(и),<br>
> цифрата 5 се среща _ път(и),<br>
> цифрата 6 се среща _ път(и),<br>
> цифрата 7 се среща _ път(и),<br>
> цифрата 8 се среща _ път(и) и<br>
> цифрата 9 се среща _ път(и).<br>

По колко различни начина Катя е можела да напише това изречение, така че то да е вярно, ако тя може да смята до 9 включително и затова в изречението има само едноцифрени числа? 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution22><label for=solution22 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Тази логическа задача в оригинал съдържа изречение с всички цифри (от 0 до 9 вкл.), без ограничение за големината на числата и е на американския математик Raphael M. Robinson.<br>
Далеч по-лесно е да се намери едно конкретно решение, отколкото да се намерят и преброят всички решения.<br>
Тъй като проверката на всички възможности е с експоненциална сложност спрямо броя на неизестните числа, за програмно решение с приемливо бързодействие е важно да се изследват възможнoтo минимално и максимално участие на всяка цифра в изречението, което, заедно с примерно решение на Java може да видите в обяснението на следващата задача.
С така зададеното условие задачата има едно единствено решения и то е:<br>
[1→6, 2→3, 3→2, 4→1, 5→1, 6→2, 7→1, 8→1, 9→1]<br>

{:/}

> В това изречение<br>
цифрата 1 се среща 6 път(и),<br>
цифрата 2 се среща 3 път(и),<br>
цифрата 3 се среща 2 път(и),<br>
цифрата 4 се среща 1 път(и),<br>
цифрата 5 се среща 1 път(и),<br>
цифрата 6 се среща 2 път(и),<br>
цифрата 7 се среща 1 път(и),<br>
цифрата 8 се среща 1 път(и) и<br>
цифрата 9 се среща 1 път(и).

{::nomarkdown}

Другите две възможности за вярно изречение съдържат двуцифрени числа, но пък и можем да ги класифицираме като тривиални:<br>
<font color="grey">
[1→10, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]<br>
[1→11, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]
</font>
	</div> 
</div>
{:/}

<hr>

Жорко е по-голям от Катя и е написал следното по-сложно изречение:

> В това изречение<br>
 цифрата 1 се среща _ път(и),<br>
 цифрата 2 се среща _ път(и),<br>
 цифрата 3 се среща _ път(и),<br>
 цифрата 4 се среща _ път(и),<br>
 цифрата 5 се среща _ път(и),<br>
 цифрата 6 се среща _ път(и),<br>
 цифрата 7 се среща _ път(и),<br>
 цифрата 8 се среща _ път(и),<br>
 цифрата 9 се среща _ път(и) и<br>
 числото 10 се среща _ път(и).

По колко различни начина Жорко е можел да напише това изречение, така че то да е вярно, ако той може да смята с произволно големи цели числа?<br>
Приемаме, че ако изречението съдържа твърдението
> числото 10 се среща 101 път(и)

то за тази част от изречението трябва да преброим 2 срещания на цифрата 0, 3 срещания на цифрата 1 и 2 срещания на числото 10.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution23><label for=solution23 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
От нескритите числа виждаме, че цифрите 0 и 1 се срещат поне по 2 пъти, а всички останали цифри и числото 10 се срещат поне по веднъж.<br>
Нека анализираме колко цифри <b title="Брой цифри в изречението">N</b> може да има в изречението?<br>
Нескритите цифри са 12. За всяко нескрито число (общо 11) добавяме поне по още 1 цифра за съответния брой срещания, т.е. <b title="Брой цифри в изречението">N</b>≥12+11=23.<br>
Ако допуснем, че има поне 2 числa d<sub>1</sub> и d<sub>2</sub>, които се срещат 10 или повече пъти, то <b title="Брой цифри в изречението">N</b>≥25, а d<sub>1</sub> и d<sub>2</sub> се срещат поне по 8 пъти всяко измежду скритите числа, обозначени с _. Понеже имаме 11 непоказани числа, в които трябва да преброим поне по 8 пъти  d<sub>1</sub> и d<sub>2</sub>, стигаме до нуждата от 5 двуцифрени непоказани числа, които изискват поне 5∗10=50 цифри в изречението и нуждата да преброим  50-12=38 цифри в непоказаните числа, което от своя страна изисква четирицифрено число там. Тъй като не можем да достигнем до крайно число брой цифри, предположението ни за второ двуцифрено число е грешно. Същото важи и за трицифрени и по-големи числа. <br>
Получихме 23≤<b title="Брой цифри в изречението">N</b>≤24 (можем да имаме 0 или 1 скрито двуцифрено число).<br>
Нека цифрата 0 се среща i<sub>0</sub> пъти, цифрата 1 се среща i<sub>1</sub> пъти, ... и числото 10 съответно i<sub>10</sub> пъти.
1. Колко най-много пъти може да срещем цифрата 0? (i<sub>1</sub>≤?)<br>
Тъй като всяко число се среща поне по веднъж, в скритите числа може да срещнем 0 само от двуцифрено число, т.е. най-много веднъж и 2 ≤ i<sub>0</sub> ≤ 3.
2. i<sub>1</sub> ≤ ?<br>
Цифрaтa 1 се среща точно 2 пъти измежду вече показаните числа. Ако едно се среща 11 пъти и всички други числа (без 0) се срещат точно по веднъж, получаваме 13≠11 ⇒ i<sub>1</sub> ≤ 12.
3. i<sub>2</sub> ≤ ?<br>
Ако i<sub>2</sub>=6, то 5 от тези срещания ще са в непоказаните числа и поне 3 от тези срещания (без тези за 0 и 1) ще изискват повторение на съответното число в изречението отново в непоказаната част. Например:<small><table>
<tr><td>Показани</td><td> </td><td>Непоказани</td></tr>
<tr><td align=center style="color:green">0</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">2</sub><td></tr>
<tr><td align=center style="color:green">1</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">3</sub><td></tr>
<tr><td align=center >2<sub style="color:black">1</sub></td><td>→&nbsp;</td><td style="color:DarkBlue">6<td></tr>
<tr><td align=center style="color:brown">3</td><td>→&nbsp;</td><td style="color:brown">2<sub style="color:black">4</sub><td></tr>
<tr><td align=center style="color:red">4</td><td>→&nbsp;</td><td style="color:red">2<sub style="color:black">5</sub><td></tr>
<tr><td align=center >5</td><td>→&nbsp;</td><td style="color:brown">3<td></tr>
<tr><td align=center style="color:DarkBlue">6</td><td>→&nbsp;</td><td style="color:DarkBlue">2<sub style="color:black">6</sub><td></tr>
<tr><td align=center >7</td><td>→&nbsp;</td><td style="color:red">4<td></tr>
<tr><td align=center >8</td><td>→&nbsp;</td><td>\_<td></tr>
<tr><td align=center >9</td><td>→&nbsp;</td><td>\_<td></tr>
<tr><td align=center style="color:green">10</td><td>→&nbsp;</td><td>\_<td></tr>
<tr><td> </td><td> </td><td> - - - <td></tr>
<tr><td> </td><td> </td><td>Поне 23+3 цифри &gt; 24<td></tr>
</table></small>Сумата на непоказаните числа обаче трябва да е &lt; <b title="Брой цифри в изречението">N</b>, понеже броим и числото 10 ⇒ i<sub>2</sub>≤5.<br>
Аналогично i<sub>3</sub>≤5, i<sub>4</sub>≤5, i<sub>5</sub>≤5, i<sub>6</sub>≤5, i<sub>7</sub>≤5, i<sub>8</sub>≤5 и i<sub>9</sub>≤5. Въпреки че тук можем да бъдем и доста по-стриктни в анализа, тези ограничения са достатъчно добри за тази версия на задачата.<br>
4. Вече знаем, че имаме най-много 1 двуцифрено число измежду непоказаните ⇒ 1≤i<sub>10</sub>≤2.<br>

{:/}

Примерен Java code:
```java
int resultCount = 0;
for (int i0 = 2; i0 <= 3; i0++)
for (int i1 = 2; i1 <= 12; i1++)
for (int i2 = 1; i2 <= 5; i2++)
for (int i3 = 1; i3 <= 5; i3++)
for (int i4 = 1; i4 <= 5; i4++)
for (int i5 = 1; i5 <= 5; i5++)
for (int i6 = 1; i6 <= 5; i6++)
for (int i7 = 1; i7 <= 5; i7++)
for (int i8 = 1; i8 <= 5; i8++)
for (int i9 = 1; i9 <= 5; i9++)
for (int i10 = 1; i10 <= 2; i10++) {
    int[] currentDigits = new int[] 
	    {i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10};
    int[] actualCounts = new int[] 
	    {2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    for (int i = 0; i <= 10; i++) {
	int num = currentDigits[i];
	if (num < 10) {
	    actualCounts[num] = actualCounts[num] + 1;
	} else {
	    int firstDigit = (num / 10);
	    int secondDigit = (num % 10);
	    actualCounts[firstDigit] = actualCounts[firstDigit] + 1;
	    actualCounts[secondDigit] = actualCounts[secondDigit] + 1;
	    if (num == 10) {
		actualCounts[10] = actualCounts[10] + 1;
	    }
	}
    }
    if (Arrays.equals(currentDigits, actualCounts)) {
	resultCount++;
	System.out.println(IntStream.range(0, 11)
		.mapToObj(n -> n + "→" + currentDigits[n])
		.collect(Collectors.joining(
			", ",
			"Решение №" + resultCount + ": [", 
			"]")));
    }
}
```

{::nomarkdown}

Получаваме следните 3 решения:<br>
Решение №1: [0→2, 1→8, 2→3, 3→3, 4→1, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №2: [0→2, 1→8, 2→4, 3→1, 4→2, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №3: [0→2, 1→11, 2→3, 3→2, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1, 10→1]<br>
<br>
И след толкова сметки, които могат да оставят погрешно впечатление, че задачата е трудна, трябва да уточним, че въпросният анализ може да се замени (в този случай доста успешно) с по-елемнтарна оценка на допустимите стойности на числата в изречението и по-неефективно решение, което би било напълно достатъчно за намиране на верния отговор.
	</div> 
</div>
{:/}

## Седмица №3

Принц посещава далечен остров, на който живеят две племена. Хората от първото племе винаги казват истината, а хората от второто племе винаги лъжат. Принцът присъства като зрител на игрите по случай новата 1823 година, на които хора от двете племена играят своя общ островитянски танц. Играта е по двойки, като от време на време някои хора сменят своя партньор, някои хора влизат, а други излизат от играта. След игрите принцът попитал всеки танцувал по отделно, с колко хора, казващи истината, е играл, като записвал това число в своя тефтер. Когато приключил, принцът с учудване установил, че е получавал все различни отговори, намирайки в тефтера си числата от 0 до 1822 точно по веднъж.<br>
Колко хора, казващи истината, са взели участие в игрите?<br>
Приемаме, че всички на острова се познават помежду си и знаят кой от кое племе е.<br>
Отговорете с английската буква u (от undefined), ако информацията е недостатъчна, за да се отговори еднозначно.

{::nomarkdown}

<div>
	<input type="checkbox" id=solution31><label for=solution31 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Знаем, че в игрите са взели участие 1823 души, като всеки е отговорил с едно от числата между 0 и 1822 и никой друг не е отговорил със същото число. Нека<br> P<sub>1822</sub> e човекът, отговорил с 1822,<br>
P<sub>1821</sub> e човекът, отговорил с 1821,<br>
... <br>
P<sub>1</sub> e човекът, отговорил с 1 и <br>
P<sub>0</sub> e човекът, отговорил с 0<br>
Може ли P<sub>1822</sub> да е казал истината (и следователно винаги да казва истината)?<br>
Ако допуснем, че P<sub>1822</sub> казва истината, то тогава  P<sub>1822</sub> трябва да е играл с всички останали 1822 участници и те да казват истината. Това означава, че P<sub>1822</sub> е играл и с P<sub>0</sub> и P<sub>0</sub> казва истината. Но P<sub>0</sub> твърди, че не е играл с никой, който казва истината, което е в 
противоречие с допускането. Следователно P<sub>1822</sub> не може да е казал истината и е от хората, които винаги лъжат.<br>
Може ли P<sub>1821</sub> да казва истината?<br>
Ако допуснем, че P<sub>1821</sub> казва истината, знаейки че P<sub>1822</sub> лъже, следва, че P<sub>1821</sub> е играл с всички останали и те казват истината. Отново имаме същия проблем с P<sub>0</sub>, който е играл с P<sub>1821</sub> и едновременно казва истината, и е играл с 0 хора, казващи истината, което е противоречие с допускането, откъдето следва, че P<sub>1821</sub> лъже.<br>
Аналогично можем да заключим, че всички хора от P<sub>1820</sub> до P<sub>1</sub> включително лъжат.<br>
Какво означава това за P<sub>0</sub>?<br>
Тъй като всички останали лъжат, P<sub>0</sub> няма как да е играл с някой, който казва истината и следователно трябва да казва истината.<br>
<b>Получаваме 1 човек, който казва истината</b> и 1822<sup>-ма</sup>, които лъжат.
	</div> 
</div>
{:/}

<hr>

Колко естествени числа имат свойството сумата от цифрите и произведението от цифрите им да са равни?<br>
Ако са безкрайно много, отговорете с английската буква i (infinitely many).<br>
Приемаме, че сумата, както и произведението от цифрите на едноцифрено число са равни на самото число.

{::nomarkdown}

<div>
	<input type="checkbox" id=solution32><label for=solution32 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Нека вземем произволно многоцифрено естествено число, за което произведението от цифрите е по-голямо от сумата на цифрите му (примерно 222). От такова число можем да конструираме друго, като добавим толкова единици, колкото е разликата между произведението и сумата на цифрите (222→22211).<br>
Тъй като има безкрайно много естествени числа, за които произведението от цифрите е по-голямо от сумата на цифрите (примерно число, съставено само от цифрата 2, където тя се среща повече от 2 пъти), то има и безкрайно много съпоставими числа, за които произведението от цифрите = сумата на цифрите.<br>
Получаваме верен отговор <b>i</b> (безкрайно много).
	</div> 
</div>
{:/}

<hr>

Разполагаме с цифрите от 1 до 9, подредени във възходящ ред (всяка цифра присъства точно един път), както и с аритметичните операции събиране (+), изваждане (-), умножение (∗) и деление (/).<br>
Между всеки две съседни цифри имаме право да поставим най-много една от тези операции, като всяка операция можем да ползваме произволен брой пъти. Съседни цифри, между които не поставим операция, участват в израза като многоцифрено число.<br>
Колко различни аритметични израза, равни на 465, можем да създадем по този начин?<br>
Приемаме, че важат стандартните приоритети на операциите (умножението и делението са с по-висок приоритет от събирането и изваждането), операциите са ляво асоциативни (т.е. операции с един и същи приоритет се изпълняват от ляво надясно, например 12/3/4=1) и не можем да използваме скоби за смяна на така дефинираната последователност на изчисленията.

## Седмица №4

Пламен харесва Ани, но Ани харесва Георги.<br>
Пламен е обвързан, а Георги не е.<br>
Можем ли да твърдим със сигурност, че в компанията на Пламен, Ани и Георги (без участието на други хора) обвързан човек харесва необвързан човек?<br>
Приемаме, че човек може да бъде или обвързан, или необвързан.

<hr>

Колко са естествените числа n, за които n2 + 2019 е точен квадрат?

<hr>

Тройка на Питагор формират всеки 3 естествени числа a,b и c, всичките по-големи от 1, такива че а<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>.<br>
Колко са тройките на Питагор, при които най-малкото число е ≤ 10000, ако приемем, че наредбата на числата няма значение?<br>
Пример: (10000,10500,14500) и (10500,10000,14500) са една и съща тройка на Питагор, отговаряща на условието.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution43><label for=solution43 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

{:/}

Ако не знаем от къде да започнем, време е за <a href="https://www.google.com/search?q=generate+pythagorean+triples&rlz=1C1CHBF_enBG782BG782&oq=generate+p&aqs=chrome.3.69i57j0j35i39l2j0l2.10599j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Google</a>.<br>
Eдин конкретен алгоритъм за генериране на тройки на Питагор, например, е чрез <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple" target="_blank">формулата на Евклид</a>:<br>
Ако  \\( m \\) и  \\( n \\) са произволни естествени числа, такива че \\( m &gt; n &gt; 0 \\), то тогава ( \\( m^2 – n^2 , 2mn , m^2 + n^2 \\) ) e тройка на Питагор. Очевидно  \\( m \neq n \\), тъй като при равенство \\( m^2 + n^2 = m^2 + m^2 = 2m^2 \\), което няма как да е точен квадрат. <br>
С какво трябва да се съобразим?<br>
- Всички примитивни тройки на Питагор се генерират точно веднъж, когато и само когато числата \\( m \\) и \\( n \\) са взаимно прости и не едновременно нечетни. Понеже се интересуваме от всички тройки, не само примитивните, останалите трябва да генерираме сами, както и да се погрижим за това, да не преброим една и съща тройка 2 пъти.
- Ясно е, че най-голямото число от така генерираната тройка е  \\( m^2 + n^2 \\), понеже \\( (m^2 + n^2) - (m^2 - n^2) = 2n^2 &gt; 0,  (m^2 + n^2) - 2mn = (m-n)^2 &gt; 0\\), но не е ясно кое е най-малкото. Пример: при \\( m=2, n=1, m^2 – n^2=3&lt; 2mn=4 \\), a при \\( m=4, n=1, m^2 – n^2=15&gt; 2mn=8 \\)
- Трябва да генерираме всички възможни двойки \\( m \\) и  \\( n \\), такива че \\( m^2 – n^2 \leq 10000 \\) или \\(2mn \leq 10000 \\). Оценка на големината на \\( m + n \\), необходима при някои решения:
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( m^2 – n^2 \leq 10000\\)?
\\( m^2 – n^2 \leq 10000 \iff (m + n)(m - n) \leq 10000 \Rightarrow m + n \leq \dfrac{10000}{m - n} \leq 10000 \\)
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( 2mn \leq 10000\\)?<br>
\\( 2mn \leq 10000 \iff mn \leq 5000 \Rightarrow n \leq \dfrac{5000}{m}, m \leq 5000 \\)   \\( \Rightarrow m+n \leq m + \dfrac{5000}{m} \leq 5001 \\). <!-- Tъй като \\( m &gt; n \iff m &gt; \dfrac{5000}{m} \\) равенство получаваме само при \\( m = 5000 \\) -->

Тъй като работата с тройка обекти е сравнително стандартна и често срещана ситуация, вместо да дефинираме наш собствен клас, можем да потърсим вече съществуваща имплементация с отворен код и подходящ лиценз, например клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/Triple.html" target=_blank>ImmutableTriple</a> от Apache Commons Lang библиотеката.<br>
Допълнителни оптимизации, като например това да пазим само първите две числа на тройките на Питагор (клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/ImmutablePair.html" target=_blank>ImmutablePair</a>), също са възможни, но не са наложителни в конкретния случай.<br>

Примерен Java code:
```java
private void buildResult(Set<ImmutableTriple<Integer,Integer,Integer>> result, final int limit) {
    for(int m = 2; m < limit; m++) {
    	for (int n = 1; n < m && n + m <= limit; n++) {
            int a = m * m - n * n;
            int b = 2 * m * n;
            int c = m * m + n * n;
            if (a > b) {
            	int tmp = a;
            	a = b;
            	b = tmp;
            }
            int multiplyBy = 1;
            while (a*multiplyBy <= limit) {
            	result.add(new ImmutableTriple<>(a*multiplyBy, b*multiplyBy, c*multiplyBy));
            	multiplyBy++;
            }
    	}
    }
}
```
```java
Set<ImmutableTriple<Integer,Integer,Integer>> result = new HashSet<>();
buildResult(result, 10000);
System.out.println(result.size());
```
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>
<br>
Ако искаме да генерираме всяка тройка точно по веднъж, трябва да проверяваме, че \\( m \\) и  \\( n \\) са взаимно прости, т.е. най-големият им общ делител (НОД) = 1 и не са едновременно четни.
```java
private int gcd(int a, int b) {
	if (a == 0) return b;
	return gcd(b%a, a);	
}
```
```java
int limit = 10000;
int numberOfTriples = 0;
// k = m + n
for(int k=3; k <= limit; k+=2) {
	int n = 1;
	int m = k-n;
	while (n < m) {	
		if (gcd(m,n) == 1) {
			int a = m*m - n*n;
			int b = 2*m*n;
			//int c = m*m + n*n;
			if (a > b) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			int multiplyBy = 1;
			while (a*multiplyBy <= limit) {
				//The next triple is (a*multiplyBy , b*multiplyBy , c*multiplyBy) 
				numberOfTriples++;
				multiplyBy++;
			}
		}
		n++;
		m--;
	}
}
System.out.println(numberOfTriples);
```
{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>

	</div> 
</div>
{:/}

## Седмица №5


