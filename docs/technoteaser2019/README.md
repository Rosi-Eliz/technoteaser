# SAP Техноблъсканица 2019

<link rel="stylesheet" href="../styles/technoteaser.css">
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

{::nomarkdown}

<input type="checkbox" id=week1Toggle>
<label for=week1Toggle class="week">
<h2 id=week1>Седмица №1 <span></span></h2>
</label>	
<div>

{:/}

Играем в телевизионна игра. Разполагаме с 8 еднакви и неразличими на външен вид кутии, във всяка от които има по 2 камъчета. Всяко камъче може да бъде скъпоценно или не. Избираме една кутия и водещият, без да поглежда в нея, изважда едно от камъчетата. То се оказва скъпоценно. Тогава водещият заявява, че имаме точно 50% шанс и второто камъче в тази кутия да е скъпоценно.<br>
Ако знаем, че първоначално броят на скъпоценните камъчета е не по-малък от броя на нескъпоценните, кои от следните твърдения трябва да са верни?<br>
Приемаме, че водещият знае разпределението на камъчетата в кутиите - в колко кутии скъпоценните камъчета са 2, в колко е 1 и в колко са 0. Водещият обаче не знае какви са камъчетата в една конкретна кутия, тъй като самият той не различава кутиите. 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution11><label class="explanationbutton" for=solution11><span>Обяснения</span></label>
	<div class="explanation">
В оригинал задачата е популярна като <a href="https://en.wikibooks.org/wiki/Puzzles/Statistical_puzzles/3_Bags_of_Marbles" target="_blank">3 Bags of Marbles</a>, като най-подвеждащото в случая е да съобразим, че въпреки избора на кутия, реално имаме информация само за едно единствено камъче. Можем да се окажем в ситуацията да сме избрали кутия с две скъпоценни камъчета (нека я наречем печеливша) по два различни начина - като изтеглим първото или като изтеглим второто скъпоценно камъче от нея. От друга страна можем да се окажем в ситуацията да сме избрали непечеливша кутия само по един единствен начин - като сме изтеглили единственото пeчелившо камъче от нея.
<h3>Какво е разпределението на камъчетата?</h3>
Означаваме броя на кутиите с по 1 скъпоценно камъче (т.е. броя на непечелившите кутии) с <b title="Брой кутии с едно скъпоценно камъче">x</b>.<br>
Очевидно имаме поне 1 кутия с 2 скъпоценни камъчета, в противен случай шансът за второ скъпоценно камъче в избраната от нас кутия ще бъде 0%.<br>
1. Предполагаме, че първоначално в играта е имало 1 единствена кутия с 2 скъпоценни камъчета в нея. 
Номерираме всички скъпоценни камъчета с v<sub>i</sub> (valuable) и всички нескъпoценни с n<sub>i</sub> (not valuable)<br> 
<style> 
.box {border-style: solid; border-width: 1px; border-radius: 4px 4px 0px 0px; border-color:grey; margin:5px 5px 5px 5px; padding: 0px 2px 1px 2px; background-color:#f7f7f7;white-space: nowrap; line-height: 150%;}
</style>
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, n<sub>1</sub></span>...<span class="box">v<sub>2+x</sub>, n<sub>x</sub></span>
<br>
По колко начина може да сме стигнали до кутия с извадено скъпоценно камъче?<br>
От печеливша кутия: Изтеглено е v<sub>1</sub> или v<sub>2</sub><br>
От непечеливша кутия:  Изтеглено е v<sub>3</sub> или v<sub>4</sub> ... или v<sub>2+x</sub><br>
Тъй като двете вероятности според водещия са равни, то трябва да имаме точно 2 непечеливши случая и точно 2 кутии с по 1 скъпоценно камъче, т.е. <b title="Брой кутии с едно скъпоценно камъче">x</b>=2<br>
Получаваме общо 4 скъпоценни камъчета и 14 нескъпоценни. Но по условие скъпоценните са поне колкото нескъпоценните, затова 1 кутия с 2 скъпоценни камъчета не е възможно разпределение.<br> 
2. Ако предположим, че имаме 2 кутии с по 2 скъоценни камъчета, то <br> 
<span class="box">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box">v<sub>3</sub>, v<sub>4</sub></span> 
<span class="box">v<sub>5</sub>, n<sub>1</sub></span> 
...
<span class="box">v<sub>4+x</sub>, n<sub>x</sub></span>
<br>
Имаме 4 възможности за първо избрано камъче от печеливша кутия: v<sub>1</sub>,v<sub>2</sub>,v<sub>3</sub>,v<sub>4</sub><br>
За да имаме 4 възможности от непечеливша кутия, трябва да имаме 4 кутии с по 1 скъпоценно камъче (<b title="Брой кутии с едно скъпоценно камъче">x</b>=4)<br>
Получаваме **2 кутии с по 2 скъпоценни камъчета, 4 кутии с по 1 скъпоценнно камъче** и остават **2 кутии с 2 нескъпоценни камъчета**.<br>
3. Нека предположим, че имаме 3 кутии с по 2 скъпоценни камъчета. <br>
По аналогичен начим виждаме, че трябва да имаме <b title="Брой кутии с едно скъпоценно камъче">x</b>=6 кутии с по 1 скъпоценно камъче, но получаваме общо 3+6=9 кутии, а по условие имаме само 8. Същите разсъждения са валидни за всяко разпределение с повече от 3 печеливши кутии.<br>
Получихме единствено възможно разпределение на камъчетата, откъдето следват няколко верни твърдения:<br>
<nobr><span class="box" style="background-color:#eafff1">v<sub>1</sub>, v<sub>2</sub></span> 
<span class="box" style="background-color:#eafff1">v<sub>3</sub>, v<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#ffffed">v<sub>5</sub>, n<sub>1</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>6</sub>, n<sub>2</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>7</sub>, n<sub>3</sub></span> 
<span class="box" style="background-color:#ffffed">v<sub>8</sub>, n<sub>4</sub></span></nobr>
<nobr><span class="box" style="background-color:#f2e6e6">n<sub>5</sub>, n<sub>6</sub></span>
<span class="box" style="background-color:#f2e6e6">n<sub>7</sub>, n<sub>8</sub></span></nobr><br>
✔ _Първоначално в играта е имало точно 2 кутии с по два скъпоценни камъчета_ <br>
✔ _Първоначално половината кутии са имали по едно скъпоценно и едно нескъпоценно камъче_ <br>
✔ _Първоначално в играта е имало равен брой скъпоценни и нескъпоценни камъчета_ <br>
✔ _Първоначално броят на кутиите с 2 скъпоценни камъчета е равен на броя на кутиите с 2 нескъпоценни камъчета_ <br>
<h3>Защо остават нечетен брой камъчета и 50% вероятност за второ скъпоценно камъче?</h3>
След като сме изтеглили и видели едно от камъчетата, не всички останали камъчета участват с еднакво тегло в изчисляването на вероятността за това какво е второто камъче в кутия ни. Например броят на кутиите с по 2 нескъпоценни камъчета и съответно камъчетата от n<sub>5</sub> до n<sub>8</sub> не влияят по никакъв начин на тази вероятност.<br>
Друг поглед върху ситуацията е, че с второто камъче определяме типа кутия. В случая сме имали 50% шанс да изберем първото скъпоценно камъче и текущ шанс 50% за второ скъпоценно камъче, т.е. обща вероятност от 50%∗50%=25% за кутия с 2 скъпоценни камъчета.
<h3>Как променяме шанса си при смяна на кутията?</h3>
От 4-те непечеливши комбинации (камъчета от v<sub>5</sub> до v<sub>8</sub>), когато в кутията ни има второ нескъпоценно камъче, при премахването на нашата кутия в играта остават равен брой скъпоценни и нескъпоценни камъчета и ⇒ 50% шанс за това второто изтеглено камъче да е скъпоценно.<br>
От 4-те печеливши комбинации обаче (камъчета от v<sub>1</sub> до v<sub>4</sub>), когато в кутията ни има второ скъпоценно камъче, при премахването на нашата кутия в играта остават 6 скъпоценни и 8 нескъпоценни камъчета, т.е. имаме шанс за успех 6/14≈42.857%<br> 
Сумарно при смяна на кутиите шансът ни за второ скъпоценно камъче ще бъде по-малък ( ≈ 46.4%).
<hr>
<h3>Проверка на решението</h3>
Тъй като задачата е наистина заблуждаваща, с което е и станала известна, как можем да проверим, че решението е вярно? Все пак теорията на вероятностите е точна наука и един конкретен изход от една конкретна ситуация трябва да се сбъдва с една единствена вероятност, т.е. различни интерпретации са невъзможни.<br>
Нека вземем предложеното решение за кутии и разиграем достатъчно много на брой пъти ситуацията (например 10 000 пъти), за да придобием представа за вероятността. За целта ще напишем програма, която дословно следва условието на задачата, т.е.
1. На случаен принцип избираме една от осемте налични кутии
2. На случаен принцип избираме едно камъче от вече избраната кутия
3. Ако камъчето е нескъпоценно, игнорираме ситуацията, защото не отговаря на условието (продължаваме нататък без да правим нищо)
4. Ако камъчето е скъпоценно, преброяваме ситуацията като печеливша или не спрямо второто камъче в избраната кутия
Примерна програма на Java, преброяваща 10 000 валидни ситуации:
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; //,{0,0},{0,0}
Random r = new Random();
int successfullPositions = 0;
int unsuccessfullPositions = 0;
for(int i=0; i<10000; i++) {
	int boxIndex = r.nextInt(setup.length);
	int[] box = setup[boxIndex];
	int firstMarbleIndex = r.nextInt(2); 
	int marble = box[firstMarbleIndex];
	if (marble != 1) {
		i--;
		continue;
	}
	int secondMarbleIndex = (firstMarbleIndex+1)%2;
	if (box[secondMarbleIndex] == 1) {
		successfullPositions++;
	} else {
		unsuccessfullPositions++;
	}
}
System.out.println("successful:" + successfullPositions + "; unsuccessful:" + unsuccessfullPositions);
```

{::nomarkdown}
Единственото отклонение от оригиналната ситуация е премахването на двете кутии с по 2 нескъпоценни камъчета в тях, понеже те добавят само неефективност в изпълнението, а програмата би връщала същия резултат и без тях. Примерен резултат:
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:5010; unsuccessful:4990</div>
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:4981; unsuccessful:5019</div>
<br>
Изпълнение на програмата при равен брой кутии с по 2 и с по 1 скъпоценно камъче също показва достатъчно ясно два пъти повече печеливши ситуации спрямо непечелившите.
{:/}

```java
int[][] setup = { {1,1}, {1,1}, {1,1}, {1,1}, {1,0}, {1,0}, {1,0}, {1,0} }; 
```

{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">successful:6572; unsuccessful:3428</div>		
			
		
	</div> 
</div>
{:/}


<hr>

Колко са естествените числа (цели положителни числа ≥ 1), които са равни на произведението от цифрите си?<br>
Ако са безкрайно много, отговорете с английската буква i (от infinitely many) 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution12><label class="explanationbutton" for=solution12><span>Обяснение</span></label>
	<div class="explanation">
Разглеждаме естествените числа, които имат k цифри (k≥1) и първа цифра d<sub>1</sub>.<br>
Произведението от цифрите e най-голямо, когато всяка цифра след d<sub>1</sub> е 9, т.е. то е ≤ d<sub>1</sub>∗9<sup>k-1</sup><br>
Самото число е най-малко, когато цифрите след d<sub>1</sub> са 0, т.е. числото е  ≥ d<sub>1</sub>∗10<sup>k-1</sup>.<br>
d<sub>1</sub>∗9<sup>k-1</sup> = d<sub>1</sub>∗10<sup>k-1</sup> само при к=1<br>
⇒ едноцифрените числа от 1 до 9 (<b>общо 9 на брой</b>) са единствените естествени числа с това свойство.	
	</div> 
</div>
{:/}

<hr>

Ученик неволно откъснал един лист от учебника си по математика. След това пресметнал сумата от номерата на останалите страници в учебника и получил 2019 +/- 1 (2018, 2019 или 2020, за да бъдем по-точни).<br>
Колко страници е имал първоначално учебникът?<br>
Приемаме, че само последната страница в учебника може да бъде празна и неномерирана.<br>
Ако първоначалният брой страници не може да се определи еднозначно, моля отговорете с английската буква u (от undefined). 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution13><label class=explanationbutton for=solution13><span>Обяснение</span></label>
	<div class="explanation">
Нека учебникът има оригинално <i title="Оригинален брой страници на учебника"><b>X</b></i> страници с обща сума на страниците <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, сума на страниците без откъснатия лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i> и сума на страниците на откъснатия лист <i title="Сума на страниците на откъснатия лист"><b>l</b></i>.<br>
Знаем, че <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>+<i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>, <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018, 2019 или 2020<br>
Какви предположения можем да направим за <i title="Сума на страниците на откъснатия лист"><b>l</b></i>?<br>
Ако сме откъснали последния лист, а последната страница е била празна, то <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=<i title="Оригинален брой страници на учебника"><b>X</b></i>.<br>
В противен случай <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е сума на 2 последователни числа. Всеки лист съдържа нечетно число първа по ред страница и четно число втора по ред страница (с 1 по-голяма от първата). <i title="Сума на страниците на откъснатия лист"><b>l</b></i> e сума на нечетно и четно число ⇒ <i title="Сума на страниците на откъснатия лист"><b>l</b></i> е нечетно число.<br><br>
Колко най-малко страници е имал учебникът?<br>
Нека разгледаме учебник, от който не сме скъсали лист, с X<sub>0</sub> страници и сума на страниците 2018.<br>
Номерата на страниците започват от 1 и завършват с X<sub>0</sub>, образувайки аритметична прогресия със сума = X<sub>0</sub>(X<sub>0</sub>+1)/2=2018, т.е.<nobr> X<sub>0</sub><sup>2</sup>+X<sub>0</sub>–2∗2018=0</nobr><br>
Положителният корен на квадратното уравнение e \( X_0 = \dfrac{-1+\sqrt{1+4*2*2018}}{2} \), <nobr>X<sub>0</sub> ≈ 63,03</nobr><br>
<!-- (-1+√<span style="text-decoration: overline;">1+4∗2∗2018</span>)/2= 126/2 -->
Нашият учебник е с един лист повече и следователно <i title="Оригинален брой страници на учебника"><b>X</b></i>≥64<br>
1. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=64 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=64∗65/2=2080 страници<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2018=62 страници, което е четно число и не може да е сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2019=61 страници = 30+31, но първата страница е четна и следователно също не може да е първа страница от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2080-2020=60 страници и също не могат да са от един лист.<br>
=> Учебникът няма как да е имал 64 страници.<br>
2. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=65∗66/2=2145<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2018=127=63+64. Това е предпоследният лист от учебник с 65 страници и сума на страниците без този лист <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2018 => <i title="Оригинален брой страници на учебника"><b>X</b></i>=65 e възможен отговор.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2019 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2019=126 и не може да бъде сума на страниците от един лист.<br>
При <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 получаваме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=2145-2020=125=62+63, които отново не са страници на един лист.
3. За учебник с <i title="Оригинален брой страници на учебника"><b>X</b></i>=66 страници получаваме <i title="Сума на страниците на учебника заедно с откъснатия лист"><b>N</b></i>=66∗67/2=2211, но дори за най-голямото <i title="Сума на страниците на учебника без откъснатия лист"><b>n</b></i>=2020 имаме <i title="Сума на страниците на откъснатия лист"><b>l</b></i>=191=95+96, а учебникът в този случай има само 66 страници.<br> Същите съображения са валидни и за <i title="Оригинален брой страници на учебника"><b>X</b></i>>66.<br>

Получихме единствено решение при учебник с <b>65</b> стр. <br>
Тъй като и тук има различни интерпретации за това дали трябва да преброим последната неномерирана страница или не, приемаме и отговор <b>66</b> за верен!	
	</div> 
</div>
</div>

<input type="checkbox" id=week2Toggle>
<label for=week2Toggle class="week">
<h2 id=week2>Седмица №2 <span></span></h2>
</label>	
<div>
	
{:/}

Миналата година (т.е. беше ден от 2018 г.) разговарях с Марто за неговия рожден ден. Той ми каза следното:

> Онзи ден (денят преди вчера) бях само на 14 години, но следващата година ставам на 17 години.

Каква е рождената дата на Марто?<br>
Приемаме, че на рождената си дата човек (през целия ден) е с 1 година по-възрастен, отколкото е бил на предходния ден.<br>
Моля, отговорете във формата dd.mm.yyyy (например 01.03.2019 за първи март 2019 г.) или с английската буква u (от undefined), ако рождената дата не може да бъде определена еднозначно. 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution21><label for=solution21 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Разговорът е проведен на 1 януари 2018 г.<br>
Марто има рожден ден на 31 декември.<br>
На 30.12.2017 (2 дена преди деня, в който се е провел разговора) е бил на 14.<br>
На 31.12.2017 е станал на 15.<br>
На 01.01.2018 (в деня на разговора) Марто е на 15 и през същата 2018-та година ще стане на 16.<br>
На 31.12.2019 (следващата година спрямо разговора) ще стане на 17.<br>
⇒ Марто е роден на <b>31.12.2002</b>
	</div> 
</div>
{:/}

<hr>

Катя е в първи клас и е добра по математика.<br>
Тя е написала следното изречение, заменяйки някои числа в него със символа _ (долна черта):

> В това изречение<br>
> цифрата 1 се среща _ път(и),<br>
> цифрата 2 се среща _ път(и),<br>
> цифрата 3 се среща _ път(и),<br>
> цифрата 4 се среща _ път(и),<br>
> цифрата 5 се среща _ път(и),<br>
> цифрата 6 се среща _ път(и),<br>
> цифрата 7 се среща _ път(и),<br>
> цифрата 8 се среща _ път(и) и<br>
> цифрата 9 се среща _ път(и).<br>

По колко различни начина Катя е можела да напише това изречение, така че то да е вярно, ако тя може да смята до 9 включително и затова в изречението има само едноцифрени числа? 

{::nomarkdown}
<div>
	<input type="checkbox" id=solution22><label for=solution22 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Тази логическа задача в оригинал съдържа изречение с всички цифри (от 0 до 9 вкл.), без ограничение за големината на числата и е на американския математик Raphael M. Robinson.<br>
Далеч по-лесно е да се намери едно конкретно решение, отколкото да се намерят и преброят всички решения.<br>
Тъй като проверката на всички възможности е с експоненциална сложност спрямо броя на неизестните числа, за програмно решение с приемливо бързодействие е важно да се изследват възможнoтo минимално и максимално участие на всяка цифра в изречението, което, заедно с примерно решение на Java може да видите в обяснението на следващата задача.
С така зададеното условие задачата има едно единствено решения и то е:<br>
[1→6, 2→3, 3→2, 4→1, 5→1, 6→2, 7→1, 8→1, 9→1]<br>

{:/}

> В това изречение<br>
цифрата 1 се среща 6 път(и),<br>
цифрата 2 се среща 3 път(и),<br>
цифрата 3 се среща 2 път(и),<br>
цифрата 4 се среща 1 път(и),<br>
цифрата 5 се среща 1 път(и),<br>
цифрата 6 се среща 2 път(и),<br>
цифрата 7 се среща 1 път(и),<br>
цифрата 8 се среща 1 път(и) и<br>
цифрата 9 се среща 1 път(и).

{::nomarkdown}

Другите две възможности за вярно изречение съдържат двуцифрени числа, но пък и можем да ги класифицираме като тривиални:<br>
<font color="grey">
[1→10, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]<br>
[1→11, 2→1, 3→1, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1]
</font>
	</div> 
</div>
{:/}

<hr>

Жорко е по-голям от Катя и е написал следното по-сложно изречение:

> В това изречение<br>
 цифрата 1 се среща _ път(и),<br>
 цифрата 2 се среща _ път(и),<br>
 цифрата 3 се среща _ път(и),<br>
 цифрата 4 се среща _ път(и),<br>
 цифрата 5 се среща _ път(и),<br>
 цифрата 6 се среща _ път(и),<br>
 цифрата 7 се среща _ път(и),<br>
 цифрата 8 се среща _ път(и),<br>
 цифрата 9 се среща _ път(и) и<br>
 числото 10 се среща _ път(и).

По колко различни начина Жорко е можел да напише това изречение, така че то да е вярно, ако той може да смята с произволно големи цели числа?<br>
Приемаме, че ако изречението съдържа твърдението
> числото 10 се среща 101 път(и)

то за тази част от изречението трябва да преброим 2 срещания на цифрата 0, 3 срещания на цифрата 1 и 2 срещания на числото 10.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution23><label for=solution23 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
От нескритите числа виждаме, че цифрите 0 и 1 се срещат поне по 2 пъти, а всички останали цифри и числото 10 се срещат поне по веднъж.<br>
Нека анализираме колко цифри <b title="Брой цифри в изречението">N</b> може да има в изречението?<br>
Нескритите цифри са 12. За всяко нескрито число (общо 11) добавяме поне по още 1 цифра за съответния брой срещания, т.е. <b title="Брой цифри в изречението">N</b>≥12+11=23.<br>
Ако допуснем, че има поне 2 числa d<sub>1</sub> и d<sub>2</sub>, които се срещат 10 или повече пъти, то <b title="Брой цифри в изречението">N</b>≥25, а d<sub>1</sub> и d<sub>2</sub> се срещат поне по 8 пъти всяко измежду скритите числа, обозначени с _. Понеже имаме 11 непоказани числа, в които трябва да преброим поне по 8 пъти  d<sub>1</sub> и d<sub>2</sub>, стигаме до нуждата от 5 двуцифрени непоказани числа, които изискват поне 5∗10=50 цифри в изречението и нуждата да преброим  50-12=38 цифри в непоказаните числа, което от своя страна изисква четирицифрено число там. Тъй като не можем да достигнем до крайно число брой цифри, предположението ни за второ двуцифрено число е грешно. Същото важи и за трицифрени и по-големи числа. <br>
Получихме 23≤<b title="Брой цифри в изречението">N</b>≤24 (можем да имаме 0 или 1 скрито двуцифрено число).<br>
Нека цифрата 0 се среща i<sub>0</sub> пъти, цифрата 1 се среща i<sub>1</sub> пъти, ... и числото 10 съответно i<sub>10</sub> пъти.
1. Колко най-много пъти може да срещем цифрата 0? (i<sub>1</sub>≤?)<br>
Тъй като всяко число се среща поне по веднъж, в скритите числа може да срещнем 0 само от двуцифрено число, т.е. най-много веднъж и 2 ≤ i<sub>0</sub> ≤ 3.
2. i<sub>1</sub> ≤ ?<br>
Цифрaтa 1 се среща точно 2 пъти измежду вече показаните числа. Ако едно се среща 11 пъти и всички други числа (без 0) се срещат точно по веднъж, получаваме 13≠11 ⇒ i<sub>1</sub> ≤ 12.
3. i<sub>2</sub> ≤ ?<br>
Ако i<sub>2</sub>=6, то 5 от тези срещания ще са в непоказаните числа и поне 3 от тези срещания (без тези за 0 и 1) ще изискват повторение на съответното число в изречението отново в непоказаната част. Например:
<small><table>
<tr><td>Показани</td><td> </td><td>Непоказани</td></tr>
<tr><td align=center style="color:green">0</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">2</sub></td></tr>
<tr><td align=center style="color:green">1</td><td>→&nbsp;</td><td style="color:green">2<sub style="color:black">3</sub></td></tr>
<tr><td align=center >2<sub style="color:black">1</sub></td><td>→&nbsp;</td><td style="color:DarkBlue">6</td></tr>
<tr><td align=center style="color:brown">3</td><td>→&nbsp;</td><td style="color:brown">2<sub style="color:black">4</sub></td></tr>
<tr><td align=center style="color:red">4</td><td>→&nbsp;</td><td style="color:red">2<sub style="color:black">5</sub></td></tr>
<tr><td align=center >5</td><td>→&nbsp;</td><td style="color:brown">3</td></tr>
<tr><td align=center style="color:DarkBlue">6</td><td>→&nbsp;</td><td style="color:DarkBlue">2<sub style="color:black">6</sub></td></tr>
<tr><td align=center >7</td><td>→&nbsp;</td><td style="color:red">4</td></tr>
<tr><td align=center >8</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td align=center >9</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td align=center style="color:green">10</td><td>→&nbsp;</td><td>_</td></tr>
<tr><td> </td><td> </td><td> - - - </td></tr>
<tr><td> </td><td> </td><td>Поне 23+3 цифри &gt; 24</td></tr>
</table></small>
Сумата на непоказаните числа обаче трябва да е &lt; <b title="Брой цифри в изречението">N</b>, понеже броим и числото 10 ⇒ i<sub>2</sub>≤5.<br>
Аналогично i<sub>3</sub>≤5, i<sub>4</sub>≤5, i<sub>5</sub>≤5, i<sub>6</sub>≤5, i<sub>7</sub>≤5, i<sub>8</sub>≤5 и i<sub>9</sub>≤5. Въпреки че тук можем да бъдем и доста по-стриктни в анализа, тези ограничения са достатъчно добри за тази версия на задачата.<br>
4. Вече знаем, че имаме най-много 1 двуцифрено число измежду непоказаните ⇒ 1≤i<sub>10</sub>≤2.<br>

{:/}

Примерен Java code:
```java
int resultCount = 0;
for (int i0 = 2; i0 <= 3; i0++)
for (int i1 = 2; i1 <= 12; i1++)
for (int i2 = 1; i2 <= 5; i2++)
for (int i3 = 1; i3 <= 5; i3++)
for (int i4 = 1; i4 <= 5; i4++)
for (int i5 = 1; i5 <= 5; i5++)
for (int i6 = 1; i6 <= 5; i6++)
for (int i7 = 1; i7 <= 5; i7++)
for (int i8 = 1; i8 <= 5; i8++)
for (int i9 = 1; i9 <= 5; i9++)
for (int i10 = 1; i10 <= 2; i10++) {
    int[] currentDigits = new int[] 
	    {i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10};
    int[] actualCounts = new int[] 
	    {2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    for (int i = 0; i <= 10; i++) {
	int num = currentDigits[i];
	if (num < 10) {
	    actualCounts[num] = actualCounts[num] + 1;
	} else {
	    int firstDigit = (num / 10);
	    int secondDigit = (num % 10);
	    actualCounts[firstDigit] = actualCounts[firstDigit] + 1;
	    actualCounts[secondDigit] = actualCounts[secondDigit] + 1;
	    if (num == 10) {
		actualCounts[10] = actualCounts[10] + 1;
	    }
	}
    }
    if (Arrays.equals(currentDigits, actualCounts)) {
	resultCount++;
	System.out.println(IntStream.range(0, 11)
		.mapToObj(n -> n + "→" + currentDigits[n])
		.collect(Collectors.joining(
			", ",
			"Решение №" + resultCount + ": [", 
			"]")));
    }
}
```

{::nomarkdown}

Получаваме следните 3 решения:<br>
Решение №1: [0→2, 1→8, 2→3, 3→3, 4→1, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №2: [0→2, 1→8, 2→4, 3→1, 4→2, 5→1, 6→1, 7→1, 8→2, 9→1, 10→1]<br>
Решение №3: [0→2, 1→11, 2→3, 3→2, 4→1, 5→1, 6→1, 7→1, 8→1, 9→1, 10→1]<br>
<br>
И след толкова сметки, които могат да оставят погрешно впечатление, че задачата е трудна, трябва да уточним, че въпросният анализ може да се замени (в този случай доста успешно) с по-елемнтарна оценка на допустимите стойности на числата в изречението и по-неефективно решение, което би било напълно достатъчно за намиране на верния отговор.
	</div> 
</div>
</div>

<input type="checkbox" id=week3Toggle>
<label for=week3Toggle class="week">
<h2 id=week3>Седмица №3 <span></span></h2>
</label>	
<div>
	
{:/}

Принц посещава далечен остров, на който живеят две племена. Хората от първото племе винаги казват истината, а хората от второто племе винаги лъжат. Принцът присъства като зрител на игрите по случай новата 1823 година, на които хора от двете племена играят своя общ островитянски танц. Играта е по двойки, като от време на време някои хора сменят своя партньор, някои хора влизат, а други излизат от играта. След игрите принцът попитал всеки танцувал по отделно, с колко хора, казващи истината, е играл, като записвал това число в своя тефтер. Когато приключил, принцът с учудване установил, че е получавал все различни отговори, намирайки в тефтера си числата от 0 до 1822 точно по веднъж.<br>
Колко хора, казващи истината, са взели участие в игрите?<br>
Приемаме, че всички на острова се познават помежду си и знаят кой от кое племе е.<br>
Отговорете с английската буква u (от undefined), ако информацията е недостатъчна, за да се отговори еднозначно.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution31><label for=solution31 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Знаем, че в игрите са взели участие 1823 души, като всеки е отговорил с едно от числата между 0 и 1822 и никой друг не е отговорил със същото число. Нека<br> P<sub>1822</sub> e човекът, отговорил с 1822,<br>
P<sub>1821</sub> e човекът, отговорил с 1821,<br>
... <br>
P<sub>1</sub> e човекът, отговорил с 1 и <br>
P<sub>0</sub> e човекът, отговорил с 0<br>
Може ли P<sub>1822</sub> да е казал истината (и следователно винаги да казва истината)?<br>
Ако допуснем, че P<sub>1822</sub> казва истината, то тогава  P<sub>1822</sub> трябва да е играл с всички останали 1822 участници и те да казват истината. Това означава, че P<sub>1822</sub> е играл и с P<sub>0</sub> и P<sub>0</sub> казва истината. Но P<sub>0</sub> твърди, че не е играл с никой, който казва истината, което е в 
противоречие с допускането. Следователно P<sub>1822</sub> не може да е казал истината и е от хората, които винаги лъжат.<br>
Може ли P<sub>1821</sub> да казва истината?<br>
Ако допуснем, че P<sub>1821</sub> казва истината, знаейки че P<sub>1822</sub> лъже, следва, че P<sub>1821</sub> е играл с всички останали и те казват истината. Отново имаме същия проблем с P<sub>0</sub>, който е играл с P<sub>1821</sub> и едновременно казва истината, и е играл с 0 хора, казващи истината, което е противоречие с допускането, откъдето следва, че P<sub>1821</sub> лъже.<br>
Аналогично можем да заключим, че всички хора от P<sub>1820</sub> до P<sub>1</sub> включително лъжат.<br>
Какво означава това за P<sub>0</sub>?<br>
Тъй като всички останали лъжат, P<sub>0</sub> няма как да е играл с някой, който казва истината и следователно трябва да казва истината.<br>
<b>Получаваме 1 човек, който казва истината</b> и 1822<sup>-ма</sup>, които лъжат.
	</div> 
</div>
{:/}

<hr>

Колко естествени числа имат свойството сумата от цифрите и произведението от цифрите им да са равни?<br>
Ако са безкрайно много, отговорете с английската буква i (infinitely many).<br>
Приемаме, че сумата, както и произведението от цифрите на едноцифрено число са равни на самото число.

{::nomarkdown}

<div>
	<input type="checkbox" id=solution32><label for=solution32 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Нека вземем произволно многоцифрено естествено число, за което произведението от цифрите е по-голямо от сумата на цифрите му (примерно 222). От такова число можем да конструираме друго, като добавим толкова единици, колкото е разликата между произведението и сумата на цифрите (222→22211).<br>
Тъй като има безкрайно много естествени числа, за които произведението от цифрите е по-голямо от сумата на цифрите (примерно число, съставено само от цифрата 2, където тя се среща повече от 2 пъти), то има и безкрайно много съпоставими числа, за които произведението от цифрите = сумата на цифрите.<br>
Получаваме верен отговор <b>i</b> (безкрайно много).
	</div> 
</div>
{:/}

<hr>

Разполагаме с цифрите от 1 до 9, подредени във възходящ ред (всяка цифра присъства точно един път), както и с аритметичните операции събиране (+), изваждане (-), умножение (∗) и деление (/).<br>
Между всеки две съседни цифри имаме право да поставим най-много една от тези операции, като всяка операция можем да ползваме произволен брой пъти. Съседни цифри, между които не поставим операция, участват в израза като многоцифрено число.<br>
Колко различни аритметични израза, равни на 465, можем да създадем по този начин?<br>
Приемаме, че важат стандартните приоритети на операциите (умножението и делението са с по-висок приоритет от събирането и изваждането), операциите са ляво асоциативни (т.е. операции с един и същи приоритет се изпълняват от ляво надясно, например 12/3/4=1) и не можем да използваме скоби за смяна на така дефинираната последователност на изчисленията.


{::nomarkdown}
<div>
	<input type="checkbox" id=solution33><label for=solution33 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

<a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> подход за решение на задачата изисква генерирането и проверката на всички възможни изрази. Тъй като имаме 4 аритметични операции плюс опцията да пропуснем такава, т.е. можем да считаме, че имаме 5 възможни операции, които трябва да поставим между всеки две съседни цифри (т.е. на 8 места) получаваме 5<sup>8</sup>=390625 израза, които далеч не са много. <br>

Изчисляването на аритметичен израз в Java, като спазваме приоритетите на операциите, за разлика от други езици изисква писането на немалко код. От JDK1.6 обаче можем да ползваме вградения JavaScript engine, a JavaScript-a е доста по-подходящ език в подобни ситуации, при които добавената неефективност от употребата му е приемлива.<br>
{:/}

Примерен Java code:
```java
final String[] OPERATIONS = {"*", "+", "-", "/", ""}; //allow lexicographic order of found expressions
final int[] INPUT = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9};

ScriptEngineManager factory = new ScriptEngineManager();
// create a JavaScript engine
ScriptEngine engine = factory.getEngineByName("JavaScript");

int count = 0;

for (int op1 = 0; op1 < OPERATIONS.length; op1++) 
for (int op2 = 0; op2 < OPERATIONS.length; op2++) 
for (int op3 = 0; op3 < OPERATIONS.length; op3++) 
for (int op4 = 0; op4 < OPERATIONS.length; op4++) 
for (int op5 = 0; op5 < OPERATIONS.length; op5++) 
for (int op6 = 0; op6 < OPERATIONS.length; op6++) 
for (int op7 = 0; op7 < OPERATIONS.length; op7++) 
for (int op8 = 0; op8 < OPERATIONS.length; op8++) {
	String expression = INPUT[0] + OPERATIONS[op1] + INPUT[1] + 
			OPERATIONS[op2] + INPUT[2] +
			OPERATIONS[op3] + INPUT[3] +
			OPERATIONS[op4] + INPUT[4] +
			OPERATIONS[op5] + INPUT[5] +
			OPERATIONS[op6] + INPUT[6] +
			OPERATIONS[op7] + INPUT[7] +
			OPERATIONS[op8] + INPUT[8];
	boolean expressionEvaluationResult = (boolean) engine.eval(expression + " === 465");
	if (expressionEvaluationResult) {
		count++;
		System.out.println(count + ": " + expression + "=" + 465);
	}				
}

```

1. 1∗2∗3∗4∗5+6∗7∗8+9=465
2. 1∗2∗3∗4+56∗7/8∗9=465
3. 1∗2+3-4+5+6∗78-9=465
4. 1∗2+3-4+56∗7+8∗9=465
5. 1∗2-3+456-7+8+9=465
6. 1∗23∗4∗5-67+8∗9=465
7. 1+2∗3+4-5+6∗78-9=465
8. 1+2+3∗45+6∗7∗8-9=465
9. 1+2-3∗4-5∗6+7∗8∗9=465
10. 1+2-3-45+6+7∗8∗9=465
11. 1+2-3/4∗56+7∗8∗9=465
12. 1+23∗4∗5-6-7+8+9=465
13. 1-2∗3-4-5∗6+7∗8∗9=465
14. 1-2∗34+5+67∗8-9=465
15. 1-2+3∗4-5+6∗78-9=465
16. 1-2-3∗4+567-89=465
17. 1-2/3+456+78/9=465 (минава през безкрайна периодична дроб)
18. 1/2∗34-56+7∗8∗9=465
19. 12∗3+45/6∗7∗8+9=465
20. 12∗34+5+6∗78/9=465
21. 12∗34-5∗6+78+9=465
22. 12+3∗4+56∗7/8∗9=465
23. 12+3+456-7-8+9=465
24. 12+3-4-5+6∗78-9=465
25. 12/3/4+5+6∗78-9=465
26. 12/3/4+56∗7+8∗9=465
27. 123∗4-5+67-89=465

{::nomarkdown}
	</div> 
</div>
</div>

<input type="checkbox" id=week4Toggle>
<label for=week4Toggle class="week">
<h2 id=week4>Седмица №4 <span></span></h2>
</label>	
<div>

{:/}

Пламен харесва Ани, но Ани харесва Георги.<br>
Пламен е обвързан, а Георги не е.<br>
Можем ли да твърдим със сигурност, че в компанията на Пламен, Ани и Георги (без участието на други хора) обвързан човек харесва необвързан човек?<br>
Приемаме, че човек може да бъде или обвързан, или необвързан.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution41><label for=solution41 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Нека запишем връзките в компанията под формата на мини граф.<br>
<table cellspacing="0" cellpadding="1" style="border: none; margin:0; padding:0; border-spacing:0; border-collapse: collapse;border-spacing: 0; line-height: 0.9;">
<tr><td>Пламен</td><td width="35px" align=center>→</td><td align=center>Ани</td><td width="35px" align=center>→</td><td>Георги, или</td></tr>
<tr><td>Обвързан</td><td width="35px" align=center>→</td><td align=center>?</td><td width="35px" align=center>→</td><td>Необвързан</td></tr>
</table><br>
{:/}

1. Ако Ани е необвързана, то тогава от факта, че Пламен харесва Ани следва, че обвързан харесва необвързан.<br>
2. Ако Ани е обвързана, то тогава от факта, че Ани харесва Георги отново следва, че обвързан харесва необвързан.<br>

Тъй като други възможности за обвързаността на Ани няма, следва, че <b>твърдението е вярно</b>, въпреки че не можем да кажем конкретно за кои двама души е валидно то.

{::nomarkdown}
	</div> 
</div>
{:/}

<hr>

Колко са естествените числа n, за които n2 + 2019 е точен квадрат?

{::nomarkdown}
<div>
	<input type="checkbox" id=solution42><label for=solution42 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

Нека n<sup>2</sup>+2019=x<sup>2</sup>, където x също е естествено число. Тогава<br>
x<sup>2</sup> - n<sup>2</sup> = 2019<br>
(x - n)(x + n) = 2019<br>
По колко начина можем да представим 2019 като произведение на 2 естествени числа?<br>
Разлагаме 2019 на прости множители (2019=3∗673) и получаваме следните случаи:<br>
{:/}
1. x - n = 3, x + n = 673, откъдето получаваме x = 338, n = 335
2. x - n = 1, x + n = 2019, откъдето получаваме  x = 1010 , n = 1009

{::nomarkdown}
Тъй като (x - n) &lt; (x + n) други случаи (и съответно решения) в естествени числа няма.<br>
⇒ съществуват <b>2 числа</b>, отговарящи на условието.

<h3>Решение с програма</h3>
Примерно <a href="https://en.wikipedia.org/wiki/Brute-force_search" target=_blank>Brute-force</a> решение би било да проверим програматично всички естествени числа n например до <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#MAX_VALUE" target=_blank>Integer.MAX_VALUE</a> = 2<sup>31</sup>-1. За да избегнем <a href="https://javapapers.com/core-java/java-overflow-and-underflow/" target=_blank>Integer overflow</a> в аритметичните изрази, трябва да дефинираме променливите n и x от тип long.
{:/}
```java
for (long n=1; n<Integer.MAX_VALUE; n++) {
    long x = (long) Math.sqrt(n*n + 2019);
    if (n*n + 2019 == x*x) {
    	System.out.println(n + "^2 + 2019 = " + x + "^2");
    }
}
```
{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">
335^2 + 2019 = 338^2<br>
1009^2 + 2019 = 1010^2
</div>
Виждаме, че решения имаме само за сравнително малки стойности на n, което ни навежда на идеята да оценим максимално допустимите стойности за n.<br>
Tъй като \(n^2+2019=x^2 \Rightarrow (x-n)(x+n)=2019 \Rightarrow x+n \leq 2019 \iff \)
\( \sqrt{n^2+2019}+n \leq 2019 \). Тъй като \( \sqrt{n^2+2019} &gt; n \), то следва, че  \( 2n &lt; 2019 \iff n &lt; 1009.5 \Rightarrow n \leq 1009 \)<br>
С това доказахме, че намерените <b>2 решения</b> са единствени.
	</div> 
</div>
{:/}

<hr>

Тройка на Питагор формират всеки 3 естествени числа a,b и c, всичките по-големи от 1, такива че а<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>.<br>
Колко са тройките на Питагор, при които най-малкото число е ≤ 10000, ако приемем, че наредбата на числата няма значение?<br>
Пример: (10000,10500,14500) и (10500,10000,14500) са една и съща тройка на Питагор, отговаряща на условието.

{::nomarkdown}
<div>
	<input type="checkbox" id=solution43><label for=solution43 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

{:/}

Ако не знаем от къде да започнем, време е за <a href="https://www.google.com/search?q=generate+pythagorean+triples&rlz=1C1CHBF_enBG782BG782&oq=generate+p&aqs=chrome.3.69i57j0j35i39l2j0l2.10599j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Google</a>.<br>
Eдин конкретен алгоритъм за генериране на тройки на Питагор, например, е чрез <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple" target="_blank">формулата на Евклид</a>:<br>
Ако  \\( m \\) и  \\( n \\) са произволни естествени числа, такива че \\( m &gt; n &gt; 0 \\), то тогава ( \\( m^2 – n^2 , 2mn , m^2 + n^2 \\) ) e тройка на Питагор. Очевидно  \\( m \neq n \\), тъй като при равенство \\( m^2 + n^2 = m^2 + m^2 = 2m^2 \\), което няма как да е точен квадрат. <br>
С какво трябва да се съобразим?<br>
- Всички примитивни тройки на Питагор се генерират точно веднъж, когато и само когато числата \\( m \\) и \\( n \\) са взаимно прости и не едновременно нечетни. Понеже се интересуваме от всички тройки, не само примитивните, останалите трябва да генерираме сами, както и да се погрижим за това, да не преброим една и съща тройка 2 пъти.
- Ясно е, че най-голямото число от така генерираната тройка е  \\( m^2 + n^2 \\), понеже \\( (m^2 + n^2) - (m^2 - n^2) = 2n^2 &gt; 0,  (m^2 + n^2) - 2mn = (m-n)^2 &gt; 0\\), но не е ясно кое е най-малкото. Пример: при \\( m=2, n=1, m^2 – n^2=3&lt; 2mn=4 \\), a при \\( m=4, n=1, m^2 – n^2=15&gt; 2mn=8 \\)
- Трябва да генерираме всички възможни двойки \\( m \\) и  \\( n \\), такива че \\( m^2 – n^2 \leq 10000 \\) или \\(2mn \leq 10000 \\).<br>
Оценка на големината на \\( m + n \\), необходима при някои решения:
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( m^2 – n^2 \leq 10000\\)?
\\( m^2 – n^2 \leq 10000 \iff (m + n)(m - n) \leq 10000 \Rightarrow m + n \leq \dfrac{10000}{m - n} \leq 10000 \\)
     - Каква е максималната стойност на  \\( m + n \\), такава че съществуват числа \\( 2mn \leq 10000\\) ?<br>
\\( 2mn \leq 10000 \iff mn \leq 5000 \Rightarrow n \leq \dfrac{5000}{m}, m \leq 5000 \\)   \\( \Rightarrow m+n \leq m + \dfrac{5000}{m} \leq 5001 \\). 

{::nomarkdown}
Тъй като работата с тройка обекти е сравнително стандартна и често срещана ситуация, вместо да дефинираме наш собствен клас, можем да потърсим вече съществуваща имплементация с отворен код и подходящ лиценз, например клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/Triple.html" target=_blank>ImmutableTriple</a> от Apache Commons Lang библиотеката.
Допълнителни оптимизации, като например това да пазим само първите две числа на тройките на Питагор (клас <a href="https://commons.apache.org/proper/commons-lang/apidocs/index.html?org/apache/commons/lang3/tuple/ImmutablePair.html" target=_blank>ImmutablePair</a>), също са възможни, но не са наложителни в конкретния случай.
{:/}
Примерен Java code:
```java
private void buildResult(Set<ImmutableTriple<Integer,Integer,Integer>> result, final int limit) {
    for(int m = 2; m < limit; m++) {
    	for (int n = 1; n < m && n + m <= limit; n++) {
            int a = m * m - n * n;
            int b = 2 * m * n;
            int c = m * m + n * n;
            if (a > b) {
            	int tmp = a;
            	a = b;
            	b = tmp;
            }
            int multiplyBy = 1;
            while (a*multiplyBy <= limit) {
            	result.add(new ImmutableTriple<>(a*multiplyBy, b*multiplyBy, c*multiplyBy));
            	multiplyBy++;
            }
    	}
    }
}
```
```java
Set<ImmutableTriple<Integer,Integer,Integer>> result = new HashSet<>();
buildResult(result, 10000);
System.out.println(result.size());
```
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>
<br>
Ако искаме да генерираме всяка тройка точно по веднъж, трябва да проверяваме, че \\( m \\) и  \\( n \\) са взаимно прости, т.е. най-големият им общ делител (НОД) = 1 и не са едновременно четни.
```java
private int gcd(int a, int b) {
	if (a == 0) return b;
	return gcd(b%a, a);	
}
```
```java
int limit = 10000;
int numberOfTriples = 0;
// k = m + n
for(int k=3; k <= limit; k+=2) {
	int n = 1;
	int m = k-n;
	while (n < m) {	
		if (gcd(m,n) == 1) {
			int a = m*m - n*n;
			int b = 2*m*n;
			//int c = m*m + n*n;
			if (a > b) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			int multiplyBy = 1;
			while (a*multiplyBy <= limit) {
				//The next triple is (a*multiplyBy , b*multiplyBy , c*multiplyBy) 
				numberOfTriples++;
				multiplyBy++;
			}
		}
		n++;
		m--;
	}
}
System.out.println(numberOfTriples);
```
{::nomarkdown}
<div style=" background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;">99773</div>

	</div> 
</div>
</div>

<input type="checkbox" id=week5Toggle>
<label for=week5Toggle class="week">
<h2 id=week5>Седмица №5 <span></span></h2>
</label>	
<div>
	
{:/}


Спринтьор прави една обиколка на пистата със средна скорост V<sub>1</sub>. Времето му се струва твърде слабо, затова спонтанно решава (без да спира) да изтича втората обиколка по-бързо, така че общата средна скорост от двете обиколки да бъде два пъти по-голяма от V<sub>1</sub>. С каква средна скорост V<sub>2</sub> спринтьорът трябва да изтича втората си обиколка, за да постигне това?

{::nomarkdown}

	<input type="checkbox" id=solution51><label for=solution51 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
Знаем, че V=S/t.<br>
Разстоянието и на двете обиколки е едно и също (S).<br>
Нека първата обиколка е взета за време t<sub>1</sub>, а втората за време t<sub>2</sub>.<br>
Тогава V<sub>1</sub>=S/t<sub>1</sub>, a V<sub>2</sub>=S/t<sub>2</sub>.<br>
Общата средната скорост за двете обиколки е равна на целия път, разделен на цялото време, т.е. V<sub>средно</sub>=2∗S/(t<sub>1</sub>+t<sub>2</sub>).<br>
Искаме V<sub>средно</sub>=2V<sub>1</sub>=2S/t<sub>1</sub>.<br>
Т.е. \( \dfrac{2S}{t_1} = \dfrac{2S}{t_1+t_2}  \), откъдето следва, че t<sub>2</sub>=0, което е невъзможно и 
<br><b>независимо колко бързо тича, спринтьорът няма как да постигне обща средна скорост, равна на 2∗V1</b>.		
	</div>	

<hr>

Ася живее на 3 км от брега на морето, а къщата на баба ѝ е на 5 км от брега.<br>
Една сутрин Ася решава да посети баба си, като преди това отиде до брега, за да съзерцава изгрева.<br>
Ако приемем, че брегът е права линия, най-близката точка от брега до къщата на Ася е A<sub>0</sub>, най-близката точка от брега до къщата на бабата на Ася е B<sub>0</sub> и разстоянието от A<sub>0</sub> до B<sub>0</sub> е 10 км, какъв е най-късият път (в км), който Ася може да измине, спечелвайки по този начин най-много време за съзерцание?<br>
Отговорете с точност две цифри след десетичната запетая (закръглете до стотни).<br>
	<input type="checkbox" id=solution52><label for=solution52 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">
	
<h3>Решението на програмиста:</h3>
Нека Ася съзерцава морето в точка С, такава че АС+СВ е с най-малка дължина.<br>
Минимумът математика, с който така или иначе се сблъскахме <a href="/services/web/TechQuiz/user/#/questions/67" target=_blank>миналата седмица</a>, е да приложим два пъти формулата на Питагор за правоъгълен триъгълник. Ако А<sub>0</sub>С=х, то СВ<sub>0</sub>=10-х и за целия път получаваме  \(\sqrt{3^2+x^2}+\sqrt{5^2+(10-x)^2}\) 
<br>
Как да намерим за кое х пътят е най-къс и колко точно е той?<br>
Знаем, че точката С е някъде на отсечката А<sub>0</sub>В<sub>0</sub> и за всяка друга точка, отдалечавайки се от нея, общият път ще се увеличава. 
Тъй като не търсим безкрайна точност, можем да си позволим да търсим т. С с приближение, като пробваме какво разстояние получаваме за различни точки. За целта:

{:/}

1. Ще изчислим общия път за всяка точка, отдалечена на цяло число километри от А<sub>0</sub> (проверяваме точки със стъпка от 1 км). Така ще намерим точка с най-къс общ път С<sub>1</sub>
2. Ще изчислим пътя за всяка точка на отстояние +- 1 км от С<sub>1</sub>, със стъпка 0,1 км. Така ще намерим следваща точка с най-добър път С<sub>2</sub>
3. Ще продължим да намаляваме проверявания интервал и съответно стъпката между проверяваните точки, докато се убедим, че сме намерили най-късия път със задоволителна точност.

```Java
public double getXforTheLeastTimePath(double fromX, double toX, double step) {
	double minPath =  Double.MAX_VALUE;
	double xForTheMinPath = 0;
	for(double x=fromX; x<toX; x+=step) {
		double currentPath = Math.sqrt(x*x + 9) + Math.sqrt((10-x)*(10-x) + 25);
		if (minPath > currentPath) {
			minPath = currentPath;
			xForTheMinPath = x;
		}
	System.out.println("For X from " + fromX + " to " + toX + " with step " + step + ":");
	System.out.println("\t  Min distance=" + minPath + " km for X=" +  xForTheMinPath);
	}
}
```
```Java
double x= getXforTheLeastTimePath(0, 10, 1);
x = getXforTheLeastTimePath(x-1, x+1, 0.1);
x = getXforTheLeastTimePath(x-0.1, x+0.1, 0.01);
x = getXforTheLeastTimePath(x-0.01, x+0.01, 0.001);
	
```

{::nomarkdown}

<div style="background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">For X from 0.0 to 10.0 with step 1.0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.810249675906654 km for X=4.0</br>
For X from 3.0 to 5.0 with step 0.1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806410475460032 km for X=3.8000000000000007<br>
For X from 3.7000000000000006 to 3.900000000000001 with step 0.01:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806248474865697 km for X=3.7499999999999996<br>
For X from 3.7399999999999998 to 3.7599999999999993 with step 0.001:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min distance=12.806248474865697 km for X=3.7499999999999987</div><br>
Откъдето получаваме и отговора за най-къс път от 12,806248474865697 км ≈ **12,81** <br>
Резултатът от изпълнението на програмата показва и приближението, което винаги присъства при работата с типове данни с плаваща запетая (например добавяйки 8 пъти 0,1 към числото 3 дава резултат 3.8000000000000007)

<h3>Решението на математика:</h3>

Ще проектираме къщата на бабата (т. В) спрямо линията на брега в т. В‘ <br>
<img style="max-width: 100%; object-fit: contain; " src="/services/js/TechQuiz/DocumentService/GetDocument.js?id=w6KPyWwjaTev_d624zOaGNGPRXNqVMn2_B4hbV36Uhk"><br>
Най-късият път от А до В‘ ще бъде правата линия от А до В‘. Ако АВ‘ пресича брега (А<sub>0</sub>B<sub>0</sub>) в т. С, то АС + СВ ще бъде най-късият път и за Ася. Това твърдение се доказва лесно, защото ако предположим, че има друга т. С<sub>1</sub> върху А<sub>0</sub>B<sub>0</sub>, такава че АС<sub>1</sub>+С<sub>1</sub>В &lt; АС+ВС , то понеже С<sub>1</sub>В=С<sub>1</sub>В‘ ще следва, че АС<sub>1</sub>+С<sub>1</sub>В‘ &lt; АВ‘, което е невъзможно, тъй като най-краткият път между А и В‘ е правата линия.
Как да намерим АВ‘=АС+СВ‘?
Тъй като △A<sub>0</sub>AC ~ △В<sub>0</sub>В‘С, то А<sub>0</sub>С/В<sub>0</sub>С=AA<sub>0</sub>/BB<sub>0</sub>=3/5, а ние знаем, че А<sub>0</sub>С+В<sub>0</sub>С=10 ⇒ A<sub>0</sub>C=3.75, В<sub>0</sub>С=6.25<br>
За най-къс път получаваме \(\sqrt{3^2+3,75^2}+\sqrt{5^2+6,25^2}\)  = <a href="https://www.google.bg/search?q=sqrt%283*3%2B3.75*3.75%29+%2B+sqrt%285*5%2B6.25*6.25%29&rlz=1C1CHBF_enBG782BG782&oq=sqrt%283*3%2B3.75*3.75%29+%2B+sqrt%285*5%2B6.25*6.25%29" target=_blank title="пресметни в Google">12,8062484749</a> ≈ <b>12,81</b>

<h3>Решението на физика:</h3>

Най-късият път е този, при който ъгълът, под който Ася се доближава към брега, е същият като ъгъла, под който тя трябва да се отдалечава от него (∠АСА<sub>0</sub>=∠ВСВ<sub>0</sub>)<br>
Защо това е така – вижте решението на физика в следващата задача.<br>
От тук нататък повтаряме решението на математика без нуждата от допълнително построение върху чертежа, показвайки, че △A<sub>0</sub>AC ~ △В<sub>0</sub>ВС	
	
	</div>
	
<hr>

Асен също живее на 3 км от брега и иска да отиде при дядо си, който в този момент е на лодка навътре в морето.<br>
Ако лодката е на 5 км навътре в морето и на 10 км от къщата на Асен, каква е дължината на най-бързия път за Асен (в км), ако той плува два пъти по-бавно отколкото ходи?<br>Отговорете с точност 2 цифри след десетичната запетая (закръглете до стотни).

	<input type="checkbox" id=solution53><label for=solution53 class=explanationbutton><span>Обяснение</span></label>
	<div class="explanation">

Тъй като част от пътя си Асен изминава с два пъти по-бавна скорост, то най-бързият път не е непременно най-късият - факт, който спасителите на плажа познават добре.
<h3 title="Няколко реда код">Решението на програмиста:</h3>
Ще повторим подхода от предходната задача с Ася, като единствената разлика тук е в начина, по който пресмятаме най-доброто време. Също така ще трябва да пресметнем сами дължината на А<sub>0</sub>В<sub>0</sub><br>
Тъй като △AA<sub>0</sub>C ~ △ВВ<sub>0</sub>С, АС/ВС=3/5, а АС+СВ=10 ⇒ АС=3,75 а ВС=6,25 ⇒ А<sub>0</sub>B<sub>0</sub>=А<sub>0</sub>C+CB<sub>0</sub>=  \(\sqrt{3,75^2-3^2}+\sqrt{6,25^2-5^2}=6\)  <br>
За улеснения в сметките, ще предположим, че Асен ходи със скорост 1 км/ч и плува с 0,5 км/ч. Сравнително лесно се забелязва, че промяната на скоростите на ходене пеша и плуване, като запазваме съотношението между тях, не променя точката на брега Х, даваща най-бърз път, и не променя дължината на този път. За примерния код по-долу това означава, че няма значение дали търсим минимума на d1 + 2\*d2 или на (d1 + 2*d2)*n

{:/}

```Java
public double getXforTheLeastTimePath(double fromX, double toX, double step) {
	double leastTime = 100000;
	double distanceOfTheLeastTimePath = 0;
	double xForTheLeastTimePath = 0;
	for (double x=fromX; x<=toX; x+=step) {
		double d1 = Math.sqrt(x*x + 9); 
		double d2 = Math.sqrt((6-x)*(6-x) + 25);
		double currentPathTime = d1 + 2*d2;
		if (leastTime > currentPathTime) {
			leastTime = currentPathTime;
			distanceOfTheLeastTimePath=d1 + d2;
			xForTheLeastTimePath = x;
		}
	}
	System.out.println("For x from " + fromX + " to " + toX + " with step " + step + ":");
	System.out.println("\tLeast time=" + leastTime + " for x=" +  xForTheLeastTimePath + " with overall distance=" + distanceOfTheLeastTimePath + " km");
	return xForTheLeastTimePath;
}
```
```Java
double x= getXforTheLeastTimePath(0, 6, 1);
x = getXforTheLeastTimePath(x-1, x+1, 0.1);
x = getXforTheLeastTimePath(x-0.1, x+0.1, 0.01);
x = getXforTheLeastTimePath(x-0.01, x+0.01, 0.001);
x = getXforTheLeastTimePath(x-0.001, x+0.001, 0.0001);
```

{::nomarkdown}
<div style="background: grey;border: 1px solid #ccc; color: white; display: block;padding: 5px;width: 100%;font-size: 85%;">For x from 0.0 to 6.0 with step 1.0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.770329614269007 for x=4.0 with overall distance=10.385164807134505 km<br>
For x from 3.0 to 5.0 with step 0.1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766563330422017 for x=3.900000000000001 with overall distance=10.343464585239516 km<br>
For x from 3.8000000000000007 to 4.000000000000001 with step 0.01:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766141051110553 for x=3.8499999999999996 with overall distance=10.323485449292631 km<br>
For x from 3.84 to 3.8599999999999994 with step 0.001:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766139029493285 for x=3.8529999999999984 with overall distance=10.3246678129931 km<br>
For x from 3.8519999999999985 to 3.8539999999999983 with step 1.0E-4:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least time=15.766139018747975 for x=3.853200000000001 with overall distance=10.32474671162657 km<br></div>
Получаваме разстояние от 10,32474671162657 ≈ <b>10,32</b> км
<h3 title="Tук трябва да сте сигурни в познанията си по математически анализ!">Решението на математика:</h3>

<img style="max-width: 100%; object-fit: contain; " src="/services/js/TechQuiz/DocumentService/GetDocument.js?id=A0DGbB3Js6CQx1Gscr8cbGdfiLL3MVJs-qoIWZYvQzE"><br>

\(A_0B_0=\sqrt{3,75^2-3^2}+\sqrt{6,25^2-5^2}=6 \)<br>
\(AX=d_1=\sqrt{3^2+x^2}\)<br>
\(BX=d_2=\sqrt{5^2+(6-x)^2}\)<br>

Търсим минимума на общото време \(T=Т_{пеша}+Т_{плуване}= \dfrac{d_1}{V_{пеша}}+\dfrac{d_2}{V_{плуване} }=\dfrac{\sqrt{3^2+x^2} }{V_{пеша}} + \dfrac{\sqrt{5^2+(6-x)^2}}{V_{плуване}}\)<br>
\(\dfrac{\partial T}{\partial x}=\dfrac{x}{V_{пеша}\sqrt{3^2+x^2}}-\dfrac{6-x}{V_{плуване}\sqrt{5^2+(6-x)^2} }=0\)<br>
когато \(\dfrac{6-x}{V_{плуване}\sqrt{5^2+(6-x)^2}}=\dfrac{x}{V_{пеша}\sqrt{3^2+x^2}}\) <br>
което е равносилно на \(\dfrac{V_{пеша} }{V_{плуване}}=\dfrac{x\sqrt{5^2+(6-x)^2} }{(6-x)\sqrt{3^2+x^2 }}=2\)<br>
Сметките стават отвратителни, но един математик никога не се отказва.<br>
Нека разгледаме графиката на \(x\sqrt{5^2+(6-x)^2} -2(6-x)\sqrt{3^2+x^2}=0\) 
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=1GP5W9OEIajprgTkxaQI&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+0+to+6&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+0+to+6&gs_l=psy-ab.3...72291.141007..142663...2.0..0.331.4462.42j3j0j1......0....1..gws-wiz.......0i8i30j35i39j35i304i39.fCmXxa0ybUk" target="_blank">за x от 0 до 6 </a> (интервалът, от който се интересуваме), по-малкия интервал
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=Y2T5W_yWNuj6qwG274vIDQ&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8+to+3.9&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8+to+3.9&gs_l=psy-ab.3...54201.59179..59383...0.0..0.93.701.8......0....1..gws-wiz.......0i71.YrE3ECnW6ME" target="_blank"> за x от 3,8 до 3,9</a>, където y=0, и накрая
<a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=oGT5W5mAGLLprgSPnb6oBA&q=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8532385+to+3.8532387&oq=graph+x*sqrt%285%5E2+%2B+%286-x%29%5E2%29+-+2%286-x%29sqrt%283%5E2%2Bx%5E2%29+from+3.8532385+to+3.8532387&gs_l=psy-ab.3...22884.31761..32517...0.0..0.88.673.8......0....1j2..gws-wiz.YMC5y3POHik" target="_blank">около x=3,8532386</a><br>
Така накарахме Google да пресметне корена на уравнението в търсения от нас интервал вместо нас. Без да ползваме Google, решението евентуално би минало през уравнението \(3x^4-36x^3+119x^2-432x+1296=0\) в интервала [0,6], за което можем да ползваме <a target="_blank"  href="http://www.fmi-plovdiv.org/evlm/DBbg/database/courses/2%20lekcia-k4m-2012.pdf">метода на разполовяването, на хордите или на допирателните</a>.<br>
В тази точка имаме минимум на функцията за общото време T=Т<sub>пеша</sub>+Т<sub>плуване</sub>, понеже при V<sub>пеша</sub>=1, V<sub>плуване</sub>=0,5 и x&lt;3,8532386 (например x=3,8) \(\dfrac{\partial T}{\partial x}\)&lt;0, т.е. функцията намалява, a при x&gt;3,8532386 (например x=3,9) \(\dfrac{\partial T}{\partial x}\)&gt;0, т.е. функцията нараства.<br> 
Пресмятаме \(d_1+d_2=\sqrt{3^2+x^2}+\sqrt{5^2+(6-x)^2}\) за x=3,8532386 и получаваме <a href="https://www.google.bg/search?rlz=1C1CHBF_enBG782BG782&ei=6xj5W-C5LoSzsAfE0JK4CA&q=calc+sqrt%283%5E2%2B3.8532386%5E2%29%2Bsqrt%285%5E2%2B%286-3.8532386%29%5E2%29&oq=calc+sqrt%283%5E2%2B3.8532386%5E2%29%2Bsqrt%285%5E2%2B%286-3.8532386%29%5E2%29&gs_l=psy-ab.3...63869.66508..67435...0.0..0.89.171.2......0....1j2..gws-wiz.......0i71j35i302i39.Mz_WU5xOtGM" target="_blank">10,3247619401</a>≈<b>10,32</b> км

<h3 title="От мистика към реалност">Решението на физика:</h3>

Най-бързият път между две точки е този, който светлината би изминала между тях. Това е принципа на Ферма, формулиран за първи път в далечния 1-ви януари 1662 г.<br>В общия случай може да има и повече от един най-бърз път (пътища с еднакво време).<br>
Когато между двете точки няма препятствия и промяна на скоростта, това е просто правата линия.<br>
Когато имаме отражение, както в предходната задача, тогава ъгълът на падане е равен на ъгъла на отражение. Тъй като няма промяна в скоростта, най-бързият и най-краткият път за предходната задача съвпадат.<br>
Когато светлината преминава от една среда в друга и това води до промяна в скоростта, тогава наблюдаваме пречупване (рефракция), като ъгълът на пречупване се определя от закона на Снел (Снелиус) \(\dfrac{V_1}{V_2}=\dfrac{\sin{\theta_2} }{\sin{\theta_1}}=\dfrac{x\sqrt{5^2+(d-x)^2} }{(d-x)\sqrt{3^2+x^2}}=2\) и това в случая е относителният коефициент на пречупване на втората среда спрямо първата. Като вземем тази формула наготово, спестявайки си изследването на функцията за минимум през първа производна, следват останалите изчисленията, които остават все така неизбежни.<br>
<hr>
Как светлината намира винаги най-бързия път между две точки?<br>
Всъщност това тя прави не благодарение на квантовите си свойства, като преминава през всички възможни пътища и като прави квантов скок за най-бързия от тях. Светлината е вълна, а правилото за най-бърз път важи за вълните по принцип, включително и за тези, които нямат отношение към квантовата механика, като например звуковите и морските вълни.<br>
Дали това е просто случайно следствие на вълновите свойства в природата, или пък природата не е имала друг избор, това е вече главоблъсканица от философско измерение, но както е видно по-горе понякога и няколко реда код вършат достатъчно добра работа.	
	
	</div>
</div>

{:/}

<script>
function hashChange() {
	if (window.location.hash) {
		var hashID = window.location.hash.substr(1);
		var obj = document.getElementById(hashID + "Toggle");
	        if (obj) {obj.checked = true;}
	}
}
window.onhashchange = hashChange;
hashChange();
</script>

